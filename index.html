<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fl√¢nerie - The Art of Urban Wandering</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Discover and share urban walking routes, swarms, and events in your city with Fl√¢nerie">
    <meta name="theme-color" content="#6b9b9e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Fl√¢nerie">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" sizes="152x152" href="/icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-192x192.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-72x72.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-72x72.png">
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800&family=Playfair+Display:wght@400;600;700;800&family=Crimson+Text:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        body {
            font-family: 'Poppins', sans-serif;
            overflow-x: hidden;
            background: #0a0a0a;
            color: #8DBCC0;
            --accent-color: #6B9B9E;
            --accent-light: #8DBCC0;
        }
        
        body.choreography-active {
            overflow: hidden;
            height: 100vh;
            position: fixed;
            width: 100%;
        }
        
        /* Navigation - Centered, No Logo */
        nav {
            position: fixed;
            top: 0;
            width: 100%;
            background: rgba(10, 10, 10, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            padding: 1.5rem 2rem;
            z-index: 1000;
            border-bottom: 1px solid rgba(107, 155, 158, 0.2);
        }
        
        .nav-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 0 2rem;
        }
        
        .nav-links {
            display: flex;
            gap: 3rem;
            list-style: none;
            margin-right: 300px;
        }
        
        .nav-links a {
            text-decoration: none;
            color: var(--accent-light);
            font-weight: 500;
            font-size: 1.1rem;
            transition: color 0.3s ease;
        }
        
        .nav-links a:hover {
            color: #ffffff;
        }
        
        /* Auth UI - Way over on the right */
        .nav-auth {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            position: absolute;
            right: 2rem;

        }
        
        #user-name {
            font-size: 0.85rem;
            margin-right: 0.5rem;
            display: flex;
            align-items: center;
            line-height: 1;
        }
        
        .auth-btn {
            background: linear-gradient(135deg, var(--accent-color), #8dbcc0);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }
        
        .auth-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(107, 155, 158, 0.4);
        }
        
        /* Hero Section */
        .hero {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
            padding: 6rem 2rem 4rem;
            background: url('character-bg.png') center/cover fixed;
        }
        
        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.6);
            -webkit-backdrop-filter: blur(6px);
            backdrop-filter: blur(6px);
            z-index: 1;
        }
        
        .hero-content {
            position: relative;
            z-index: 2;
            max-width: 900px;
        }
        
        .hero h1 {
            font-family: 'Playfair Display', serif;
            font-size: 7rem;
            font-weight: 400;
            color: var(--accent-light);
            margin-bottom: 1rem;
            letter-spacing: 3px;
            text-shadow: 0 5px 30px rgba(0, 0, 0, 0.8);
        }
        
        .hero-subtitle {
            font-size: 1.8rem;
            color: var(--accent-light);
            font-weight: 300;
            margin-bottom: 2rem;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }
        
        .hero-logo-btn {
            width: 200px;
            height: 200px;
            margin: 0 auto 2rem;
            border-radius: 50%;
            background: url('character-logo.png') center/cover;
            border: 5px solid var(--accent-color);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 40px rgba(107, 155, 158, 0.4);
            animation: float 3s ease-in-out infinite;
        }
        
        .hero-logo-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 60px rgba(107, 155, 158, 0.6);
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        /* Rotating phrases below logo */
        .rotating-text-container {
            min-height: 50px;
            position: relative;
            margin-bottom: 1rem;
        }
        
        .rotating-text {
            position: relative;
            width: 100%;
            text-align: center;
        }
        
        .rotating-text span {
            position: absolute;
            width: 100%;
            left: 0;
            opacity: 0;
            color: var(--accent-light);
            font-size: 1.2rem;
            font-weight: 300;
            font-style: italic;
            transition: opacity 1s ease-in-out;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }
        
        .rotating-text span.active {
            opacity: 1;
        }
        
        .scroll-hint {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            color: var(--accent-light);
            font-size: 0.9rem;
            opacity: 0.7;
            animation: bounce 2s ease-in-out infinite;
            z-index: 2;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }
        
        /* PWA Install Banner */
        .pwa-install-banner {
            display: none;
            position: fixed;
            top: 140px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, var(--accent-color), #5a8a8d);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 50px;
            box-shadow: 0 4px 20px rgba(107, 155, 158, 0.4);
            z-index: 999;
            animation: slideDown 0.5s ease-out;
            max-width: 90%;
            text-align: center;
            /* Auto-hide after 10 seconds */
            animation: slideDown 0.5s ease-out, fadeOut 1s ease 10s forwards;
        }
        
        .pwa-install-banner.show {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .pwa-install-banner button {
            background: white;
            color: var(--accent-color);
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        
        .pwa-install-banner .close-banner {
            background: transparent;
            color: white;
            padding: 0.25rem 0.5rem;
            font-size: 1.2rem;
        }
        
        @keyframes slideDown {
            from {
                top: -100px;
                opacity: 0;
            }
            to {
                top: 140px;
                opacity: 1;
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
                display: none;
            }
        }
        
        @media (max-width: 768px) {
            .pwa-install-banner {
                font-size: 0.85rem;
                padding: 0.6rem 1rem;
                top: auto;
                bottom: 80px;
                animation: slideUp 0.5s ease-out, fadeOut 1s ease 10s forwards;
            }
            .pwa-install-banner button {
                padding: 0.4rem 1rem;
                font-size: 0.8rem;
            }
        }
        
        @keyframes slideUp {
            from {
                bottom: -100px;
                opacity: 0;
            }
            to {
                bottom: 80px;
                opacity: 1;
            }
        }
        
        @keyframes fadeOutMobile {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
                pointer-events: none;
            }
        }
        
        /* Main Content */
        .main-content {
            position: relative;
            background: #0a0a0a;
            padding: 6.5rem 0 2rem;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }
        
        /* Info Section - Definition */
        .info-section {
            text-align: center;
            padding: 1.5rem 0 0.5rem;
            max-width: 900px;
            margin: 0 auto 1.5rem;
        }
        
        .definition-box-animated {
            margin-bottom: 1.2rem;
            text-align: left;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
            background: rgba(30, 30, 30, 0.8);
            padding: 1.3rem;
            border-radius: 15px;
            border-left: 4px solid var(--accent-color);
        }
        
        .definition-box-animated h2 {
            font-family: 'Playfair Display', serif;
            font-size: 2.6rem;
            font-weight: 400;
            color: var(--accent-light);
            margin-bottom: 0.4rem;
        }
        
        .definition-box-animated p {
            color: var(--accent-light);
            line-height: 1.7;
        }
        
        /* Welcome Section - Wider */
        #welcome-section {
            text-align: left;
            max-width: 1200px;
            margin: 0 auto 2rem;
            background: rgba(30, 30, 30, 0.5);
            padding: 2rem 3rem;
            border-radius: 20px;
        }
        
        #welcome-section h3 {
            font-family: 'Playfair Display', serif;
            color: var(--accent-color);
            font-size: 2.5rem;
            margin-bottom: 1.2rem;
        }
        
        #welcome-section p {
            font-size: 0.95rem;
            color: var(--accent-light);
            line-height: 1.65;
            margin-bottom: 0.9rem;
        }
        
        #welcome-section p:last-of-type {
            margin-bottom: 0;
        }
        
        #tagline-reveal {
            margin-top: 1rem;
            font-family: 'Playfair Display', serif;
            font-size: 1.8rem;
            color: var(--accent-color);
            font-style: italic;
            font-weight: 700;
            text-align: center;
        }
        
        /* Feature Cards - 3 Cards */
        .features-section {
            min-height: auto;
            padding: 2.5rem 2rem 2rem;
            scroll-margin-top: 80px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
        }
        
        @media (max-width: 1024px) {
            .feature-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        @media (max-width: 968px) {
            .feature-grid {
                grid-template-columns: 1fr;
                gap: 2rem;
            }
        }
        
        .feature-card-large {
            background: rgba(30, 30, 30, 0.9);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 2px solid rgba(107, 155, 158, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 280px;
            max-height: 360px;
        }
        
        .feature-card-large:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 60px rgba(107, 155, 158, 0.3);
            border-color: var(--accent-color);
        }
        
        .feature-content {
            position: relative;
            z-index: 3;
            text-align: center;
            width: 100%;
        }
        
        .feature-icon {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--accent-color), var(--accent-light));
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            margin: 0 auto 1rem;
        }
        
        .feature-card-large h3 {
            font-family: 'Playfair Display', serif;
            font-size: 1.5rem;
            color: var(--accent-light);
            margin-bottom: 0.75rem;
        }
        
        .feature-card-large p {
            font-size: 1rem;
            color: #d4d4d4;
            line-height: 1.5;
            margin-bottom: 1rem;
        }
        
        .feature-btn {
            background: linear-gradient(135deg, var(--accent-color), var(--accent-light));
            color: white;
            padding: 0.75rem 1.85rem;
            border: none;
            border-radius: 50px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .feature-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(107, 155, 158, 0.5);
        }
        
        .feature-btn:disabled {
            background: rgba(80, 80, 80, 0.5);
            color: rgba(255, 255, 255, 0.4);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .feature-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        /* Footer */
        footer {
            background: rgba(10, 10, 10, 0.98);
            color: var(--accent-light);
            padding: 2rem 2rem 1rem;
            border-top: 2px solid rgba(107, 155, 158, 0.3);
        }
        
        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2rem;
            margin-bottom: 1rem;
        }
        
        @media (max-width: 768px) {
            .footer-content {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .footer-section h4 {
            color: var(--accent-color);
            margin-bottom: 1rem;
        }
        
        .footer-section a {
            color: var(--accent-light);
            text-decoration: none;
            line-height: 2;
            transition: color 0.3s;
        }
        
        .footer-section a:hover {
            color: #ffffff;
        }
        
        .footer-section ul {
            list-style: none;
        }
        
        .footer-bottom {
            text-align: center;
            padding-top: 2rem;
            border-top: 1px solid rgba(107, 155, 158, 0.2);
            color: #999;
        }
        
        /* SLIDESHOW - CORRECTED */
        .slideshow-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            background: #0a0a0a;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
        }
        
        .slideshow-overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            padding: 4rem 2rem;
        }
        
        .slide.active {
            opacity: 1;
        }
        
        .slide-content {
            text-align: center;
            max-width: 800px;
            width: 100%;
        }
        
        #slide-typewriter-with-image {
            justify-content: flex-start;
            padding-top: 10%;
        }
        
        #slide-typewriter-with-image .typewriter-section {
            margin-bottom: 2.5rem;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #slide-typewriter-with-image .image-section {
            opacity: 0;
            transition: opacity 4s ease-in;
            display: flex;
            justify-content: center;
            width: 100%;
        }
        
        #slide-typewriter-with-image .image-section.fading {
            opacity: 1;
        }
        
        #slide-paragraph-with-image {
            justify-content: flex-start;
            padding-top: 8%;
        }
        
        #slide-paragraph-with-image .paragraph-section {
            margin-bottom: 3rem;
            display: flex;
            justify-content: center;
            width: 100%;
        }
        
        #slide-paragraph-with-image .image-section {
            opacity: 0;
            transition: opacity 3s ease-in;
            margin-top: 2rem;
            display: flex;
            justify-content: center;
            width: 100%;
        }
        
        #slide-paragraph-with-image .image-section.fading {
            opacity: 1;
        }
        
        #slide-paragraph-with-image .you-text {
            opacity: 0;
            transition: opacity 1.5s ease-in;
            font-family: 'Playfair Display', serif;
            color: var(--accent-color);
            font-size: 4rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        
        #slide-paragraph-with-image .you-text.showing {
            opacity: 1;
        }
        
        #slide-welcome #welcome-text {
            font-family: 'Playfair Display', serif;
            color: var(--accent-color);
            font-size: 3rem;
            font-weight: 600;
            transition: transform 2s ease-out;
        }
        
        #slide-welcome #welcome-text.move-up {
            transform: translateY(-40px);
        }
        
        #slide-welcome #tagline-text {
            font-family: 'Playfair Display', serif;
            font-size: 2.5rem;
            color: var(--accent-color);
            font-style: italic;
            font-weight: 700;
            opacity: 0;
            margin-top: 2rem;
            transition: opacity 1s ease-in;
        }
        
        #slide-welcome #tagline-text.fade-in {
            opacity: 1;
        }
        
        #slideshow-typewriter-sentence {
            font-family: 'Crimson Text', serif;
            font-size: 1.6rem;
            color: var(--accent-light);
            font-weight: 600;
            text-align: center;
            min-height: 50px;
        }
        
        .slideshow-controls {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 10001;
            display: flex;
            gap: 1rem;
        }
        
        .slideshow-controls button {
            background: rgba(107, 155, 158, 0.3);
            border: 2px solid var(--accent-color);
            color: var(--accent-color);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
        }
        
        .slideshow-controls button:hover {
            background: var(--accent-color);
            color: #0a0a0a;
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            /* Fix Navigation Overlap - Issue 4 */
            nav {
                padding: 1rem;
            }
            
            .nav-container {
                flex-direction: column;
                gap: 1rem;
                padding: 0;
            }
            
            .nav-links {
                gap: 1rem;
                font-size: 0.85rem;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .nav-auth {
                position: relative;
                right: auto;
                margin-top: 0.5rem;
            }
            
            .auth-btn {
                padding: 0.5rem 1rem;
                font-size: 0.85rem;
            }
            
            #user-name {
                font-size: 0.8rem;
            }
            
            /* Hero Section */
            .hero h1 {
                font-size: 3.5rem;
            }
            
            .hero-subtitle {
                font-size: 1.2rem;
            }
            
            .hero-logo-btn {
                width: 150px;
                height: 150px;
            }
            
            .container {
                padding: 0 1rem;
            }
            
            #welcome-section {
                padding: 2rem;
            }
            
            .definition-box-animated h2 {
                font-size: 2.5rem;
            }
            
            /* Fix Maps - Issue 1 */
            #searchMap, #swarmMap, #eventMap {
                height: 300px !important;
                min-height: 300px !important;
            }
            
            /* Fix Slideshow Images - Issue 2 */
            .slideshow-slide img {
                max-width: 100%;
                max-height: 60vh;
                width: auto !important;
                height: auto !important;
                object-fit: contain;
            }
            
            #empty-street-section img,
            #shopping-street-section img {
                max-width: 100%;
                max-height: 50vh;
                width: auto !important;
                height: auto !important;
                object-fit: contain;
            }
            
            /* Fix Dashboard - Issue 3 */
            .modal-content {
                width: 95%;
                max-height: 85vh;
                padding: 1rem;
            }
            
            #dashboardContent {
                max-height: 50vh !important;
            }
            
            .dashboard-tab {
                padding: 0.75rem 1rem !important;
                font-size: 0.85rem !important;
            }
            
            /* Fix Slideshow Controls - buttons overlapping */
            .slideshow-controls {
                bottom: 1rem;
                right: 1rem;
                gap: 0.5rem;
            }
            
            .slideshow-controls button {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }
            
            /* Fix YOU Slide - text taking too much space */
            #slide-paragraph-with-image {
                padding-top: 5%;
            }
            
            #slide-paragraph-with-image .paragraph-section p {
                font-size: 1rem !important;
                line-height: 1.6 !important;
                padding: 0 1rem;
            }
            
            #slide-paragraph-with-image .paragraph-section {
                margin-bottom: 1.5rem !important;
            }
            
            #slide-paragraph-with-image .you-text {
                font-size: 2.5rem !important;
                margin-bottom: 0.5rem !important;
            }
            
            #slide-paragraph-with-image .image-section {
                margin-top: 1rem !important;
            }
            
            #slide-paragraph-with-image .image-section img {
                max-height: 30vh !important;
            }
            
            /* FIX: Profile modal content cutoff */
            .modal-content {
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch;
            }
            
            /* FIX: Leaflet map preview sizing in cards */
            .leaflet-container {
                min-height: 250px !important;
                height: 250px !important;
            }
            
            /* FIX: Ensure card content isn't cut off */
            div[style*="cursor: pointer"][style*="margin-bottom"] {
                max-height: none !important;
                overflow: visible !important;
            }
            
            /* FIX: Modal close button overlapping content */
            .close {
                position: absolute !important;
                top: 10px !important;
                right: 10px !important;
                z-index: 10001 !important;
                background: rgba(0,0,0,0.5) !important;
                border-radius: 50% !important;
                width: 35px !important;
                height: 35px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
            }
        }
        
        /* Modal Styles */
        .modal {
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: linear-gradient(135deg, rgba(20, 20, 20, 0.98), rgba(30, 30, 30, 0.98));
            padding: 2rem;
            border-radius: 20px;
            border: 2px solid rgba(107, 155, 158, 0.3);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        
        .close:hover {
            color: var(--accent-light);
        }
        
        /* Search Field Pulse Animation */
        @keyframes searchPulse {
            0%, 100% {
                border-color: rgba(107, 155, 158, 0.3);
                box-shadow: 0 0 0 0 rgba(107, 155, 158, 0);
            }
            50% {
                border-color: rgba(107, 155, 158, 0.8);
                box-shadow: 0 0 20px 5px rgba(107, 155, 158, 0.4);
            }
        }
    </style>
</head>
<body>
    <!-- SLIDESHOW -->
    <div id="slideshow-overlay" class="slideshow-overlay">
        <div class="slideshow-controls">
            <button id="rewind-btn" title="Restart">‚Ü∫</button>
            <button id="pause-btn" title="Pause/Play">‚è∏</button>
            <button id="skip-btn" title="Skip">‚è≠</button>
        </div>
        
        <!-- Slide 1: Definition -->
        <div class="slide active" id="slide-definition">
            <div class="slide-content">
                <h2 style="font-family: 'Playfair Display', serif; font-size: 4rem; color: var(--accent-light); margin-bottom: 1rem;">fl√¢nerie</h2>
                <p style="font-size: 1.2rem; color: var(--accent-light); margin-bottom: 2rem; font-style: italic;">| Ààfl…ëÀên…ôri |</p>
                <p style="font-size: 1.6rem; color: var(--accent-light); line-height: 1.8;">The art of leisurely urban exploration;<br>mindful wandering through city streets<br>with intention and curiosity.</p>
            </div>
        </div>
        
        <!-- Slide 2: Typewriter + Image -->
        <div class="slide" id="slide-typewriter-with-image">
            <div class="typewriter-section">
                <h3 style="font-family: 'Playfair Display', serif; color: var(--accent-color); font-size: 2.8rem; margin-bottom: 2.5rem; text-align: center;">Take Back Your Main Street</h3>
                <p id="slideshow-typewriter-sentence"></p>
            </div>
            
            <div class="image-section" id="empty-street-section">
                <img src="empty-street.png" alt="Empty street" style="max-width: 500px; width: 80%; height: auto; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
            </div>
        </div>
        
        <!-- Slide 3: Paragraph + YOU + Image -->
        <div class="slide" id="slide-paragraph-with-image">
            <div class="paragraph-section">
                <p style="font-size: 1.3rem; color: var(--accent-light); line-height: 1.9; text-align: center; max-width: 800px;">
                    Search engines direct you to chains. Online shopping replaces neighborhood stores. Meanwhile, the caf√© owner who remembers your name can't make rent. Small businesses don't have marketing budgets or algorithms working for them ‚Äî they have...
                </p>
            </div>
            
            <div class="you-text" id="you-text">YOU</div>
            
            <div class="image-section" id="shopping-street-section">
                <img src="shopping-street.png" alt="Shopping street" style="max-width: 500px; width: 80%; height: auto; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.5);">
            </div>
        </div>
        
        <!-- Slide 4: Welcome -->
        <div class="slide" id="slide-welcome">
            <div class="slide-content">
                <h3 id="welcome-text">Welcome to Fl√¢nerie</h3>
                <p id="tagline-text">
                    Share your journey.<br>Retrace theirs.
                </p>
            </div>
        </div>
    </div>
    
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <ul class="nav-links">
                <li><a href="#home">Home</a></li>
                <li><a href="javascript:void(0)" onclick="scrollToContent()">How It Works</a></li>
                <li><a href="javascript:void(0)" onclick="scrollToExplore()">Explore</a></li>
                <li><a href="for-businesses.html">For Businesses</a></li>
                <li><a href="about.html">About</a></li>
            </ul>
            
            <!-- Auth UI -->
            <div class="nav-auth">
                <button id="sign-in-btn" class="auth-btn" onclick="showSignInModal()">Sign In</button>
                <div id="user-info" style="display: none;">
                    <span id="user-name" style="color: var(--accent-light);">Hi, User!</span>
                    <button class="auth-btn" onclick="openDashboard()">Dashboard</button>
                    <button id="sign-out-btn" class="auth-btn" onclick="signOut()">Sign Out</button>
                </div>
            </div>
        </div>
    </nav>
    
    <!-- Email Verification Banner -->
    <div id="verification-banner" style="display: none; position: fixed; top: 80px; left: 0; right: 0; background: linear-gradient(135deg, rgba(255, 152, 0, 0.95), rgba(255, 193, 7, 0.95)); padding: 1rem 2rem; text-align: center; z-index: 999; border-bottom: 2px solid rgba(255, 152, 0, 0.5);">
        <p style="margin: 0; color: #000; font-weight: 600; font-size: 1rem;">
            ‚úÖ You're signed in! üìß Check your email and click the verification link to start posting. 
            <span style="color: #000; font-size: 0.85rem; opacity: 0.8;">(Auto-checking...)</span>
            <a href="javascript:void(0)" onclick="resendVerificationEmail()" style="color: #000; text-decoration: underline; font-weight: 700; cursor: pointer; margin-left: 1rem;">Resend email</a>
        </p>
    </div>
    
    <!-- PWA Install Banner (Shows device-specific instructions) -->
    <div id="pwa-install-banner" class="pwa-install-banner">
        <!-- Android instructions -->
        <span id="pwa-android-text" style="display: none;">
            üì± Install Fl√¢nerie app! Tap the <strong>Install</strong> button below or use <strong>Menu ‚Üí Install app</strong>
        </span>
        <!-- iPhone instructions -->
        <span id="pwa-ios-text" style="display: none;">
            üì± Install Fl√¢nerie app! Tap <strong>Share ‚¨ÜÔ∏è</strong> then <strong>Add to Home Screen</strong>
        </span>
        <button id="pwa-install-btn" style="display: none;">Install</button>
        <button class="close-banner" onclick="document.getElementById('pwa-install-banner').classList.remove('show')">‚úï</button>
    </div>
    
    <!-- Hero Section -->
    <section class="hero" id="home">
        <div class="hero-content">
            <h1>Fl√¢nerie</h1>
            <p class="hero-subtitle">The art of urban wandering.</p>
            <div class="hero-logo-btn" onclick="scrollToContent()"></div>
            
            <!-- Rotating phrases below logo -->
            <div class="rotating-text-container">
                <div class="rotating-text">
                    <span class="active">Wander well.</span>
                    <span>Walk kindly.</span>
                    <span>Support local business.</span>
                    <span>Discover hidden gems in your neighborhood.</span>
                    <span>Turn ordinary walks into extraordinary adventures.</span>
                    <span>Connect with your community, one step at a time.</span>
                    <span>Every block has a story to tell.</span>
                    <span>Shop small, feel big.</span>
                    <span>Find your city's secrets.</span>
                    <span>Life moves fast - walk slower.</span>
                </div>
            </div>
        </div>
    </section>
    
    <!-- Main Content -->
    <main class="main-content">
        <div class="container">
            <!-- Definition Section -->
            <section class="info-section">
                <div class="definition-box-animated">
                    <h2>fl√¢nerie</h2>
                    <p style="font-size: 1rem; color: var(--accent-light); margin-bottom: 0.3rem;">
                        | Ààfl…ëÀên…ôri | <span style="font-style: italic;">noun</span>
                    </p>
                    <div style="width: 60px; height: 1px; background: #555; margin: 1rem 0;"></div>
                    <p style="font-size: 1.3rem; color: var(--accent-light); line-height: 1.7;">
                        The art of leisurely urban exploration; mindful wandering through city streets with intention and curiosity.
                    </p>
                </div>
                
                <!-- Welcome Section -->
                <div id="welcome-section">
                    <h3>Welcome to Fl√¢nerie</h3>
                    
                    <p>
                        We turn ordinary walks into extraordinary mini-adventures. Rooted in French culture, fl√¢nerie celebrates <strong style="color: var(--accent-color);">the art of strolling</strong> ‚Äî observing city life with intention instead of rushing through it. It's <strong style="color: var(--accent-color);">cultural appreciation</strong> in motion: slowing down enough to notice the character and charm built into the everyday.
                    </p>
                    
                    <p>
                        With Fl√¢nerie, you can explore neighborhoods at your own pace or chart your own path. Our routes guide you from cozy caf√©s and local markets to boutique shops, art galleries, bookstores, parks, and hidden corners ‚Äî each designed for <strong style="color: var(--accent-color);">mindful wandering</strong> and curiosity-led discovery. Search routes shared by others, map your upcoming outings, browse local events, or gather friends for a <strong style="color: var(--accent-color);">Shopping Swarm</strong> ‚Äî a collective walk that turns routine errands into moments of connection and community support.
                    </p>
                    
                    <p>
                        <strong style="color: var(--accent-color);">Your route to that tiny coffee roaster? Someone else's new favorite spot. Your Shopping Swarm? A local merchant's best weekend in months.</strong> This is how communities strengthen themselves ‚Äî one walk, one recommendation, one conscious choice at a time.
                    </p>
                </div>
                
                <p id="tagline-reveal">Share your journey. Retrace theirs.</p>
            </section>
            
            <!-- Feature Cards - 3 cards with 2 buttons each -->
            <div id="features-content" class="features-section">
                <div class="feature-grid">
                    <!-- Card 1: Journeys & Routes -->
                    <div class="feature-card-large">
                        <div class="feature-content">
                            <div class="feature-icon">üìç</div>
                            <h3>Journeys & Routes</h3>
                            <p>Share your path or discover new ones</p>
                            <button class="feature-btn" onclick="toggleSection('journey-map')" style="margin-bottom: 0.75rem;">Share Your Journey</button>
                            <button class="feature-btn" onclick="toggleSection('search')">Search Routes</button>
                        </div>
                    </div>
                    
                    <!-- Card 2: Shopping Swarms -->
                    <div class="feature-card-large">
                        <div class="feature-content">
                            <div class="feature-icon">üõçÔ∏è</div>
                            <h3>Shopping Swarms</h3>
                            <p>Create or join community walks</p>
                            <button class="feature-btn" onclick="toggleSection('swarm-map-v2')" style="margin-bottom: 0.75rem;">Create Shopping Swarm</button>
                            <button class="feature-btn" onclick="toggleSection('swarms')">View Swarms</button>
                        </div>
                    </div>
                    
                    <!-- Card 3: Local Events -->
                    <div class="feature-card-large">
                        <div class="feature-content">
                            <div class="feature-icon">üéâ</div>
                            <h3>Local Events</h3>
                            <p>Promote events or discover celebrations</p>
                            <button class="feature-btn" onclick="toggleSection('event-map-v2')" style="margin-bottom: 0.75rem;">Promote Your Event</button>
                            <button class="feature-btn" onclick="toggleSection('events')">Browse Events</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <!-- Footer -->
    <footer>
        <div class="footer-content">
            <div class="footer-section">
                <h4>Fl√¢nerie</h4>
                <p>The art of urban wandering.</p>
            </div>
            <div class="footer-section">
                <h4>Legal & Info</h4>
                <ul>
                    <li><a href="about.html">About Us</a></li>
                    <li><a href="for-businesses.html">For Businesses</a></li>
                    <li><a href="privacy.html">Privacy Policy</a></li>
                    <li><a href="terms.html">Terms of Use</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Community</h4>
                <ul>
                    <li><a href="javascript:void(0)" onclick="scrollToExplore()">Explore Routes</a></li>
                    <li><a href="javascript:void(0)" onclick="scrollToSection('events')">Browse Events</a></li>
                    <li><a href="javascript:void(0)" onclick="scrollToSection('swarms')">Discover Swarms</a></li>
                </ul>
            </div>
            <div class="footer-section">
                <h4>Connect</h4>
                <div style="display: flex; gap: 1.5rem; font-size: 1.8rem; margin-top: 1rem;">
                    <a href="https://instagram.com" target="_blank" title="Instagram" style="color: var(--accent-light); transition: color 0.3s;">üì∑</a>
                    <a href="https://facebook.com" target="_blank" title="Facebook" style="color: var(--accent-light); transition: color 0.3s;">üë•</a>
                    <a href="https://x.com" target="_blank" title="X (Twitter)" style="color: var(--accent-light); transition: color 0.3s;">üê¶</a>
                </div>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2025 Fl√¢nerie. All rights reserved. Made with ‚ù§Ô∏è for urban explorers.</p>
        </div>
    </footer>
    
    <script>
        // SLIDESHOW - APPROVED TIMING
        const typewriterText = "Every year, 200,000 small businesses close in the U.S. alone.";
        let charIndex = 0;
        
        function startSlideshow() {
            const slideshowOverlay = document.getElementById('slideshow-overlay');
            document.body.classList.add('choreography-active');
            slideshowOverlay.classList.add('active');
            
            // Slide 1: Definition (4 sec)
            setTimeout(() => {
                document.getElementById('slide-definition').classList.remove('active');
                document.getElementById('slide-typewriter-with-image').classList.add('active');
                
                // Start image fade when typing starts (slower now - 4s)
                setTimeout(() => {
                    document.getElementById('empty-street-section').classList.add('fading');
                }, 100);
                
                // Start typewriter
                slideshowTypewriter(() => {
                    // Hold for 5 seconds after typing finishes
                    setTimeout(() => {
                        document.getElementById('slide-typewriter-with-image').classList.remove('active');
                        document.getElementById('slide-paragraph-with-image').classList.add('active');
                        
                        // Paragraph HOLDS for 4 seconds (people can read)
                        setTimeout(() => {
                            // YOU fades in
                            document.getElementById('you-text').classList.add('showing');
                            
                            // Wait for YOU to finish fading (1.5 sec), then start image
                            setTimeout(() => {
                                document.getElementById('shopping-street-section').classList.add('fading');
                                
                                // Wait for image to finish (3 sec), then hold
                                setTimeout(() => {
                                    // Everything holds for 3 seconds
                                    setTimeout(() => {
                                        document.getElementById('slide-paragraph-with-image').classList.remove('active');
                                        document.getElementById('slide-welcome').classList.add('active');
                                        
                                        // After 2 sec, move Welcome up and fade in tagline
                                        setTimeout(() => {
                                            document.getElementById('welcome-text').classList.add('move-up');
                                            document.getElementById('tagline-text').classList.add('fade-in');
                                            
                                            // Hold for 4 sec, then END
                                            setTimeout(() => {
                                                slideshowOverlay.style.transition = 'opacity 1s ease-out';
                                                slideshowOverlay.style.opacity = '0';
                                                
                                                setTimeout(() => {
                                                    slideshowOverlay.style.display = 'none';
                                                    document.body.classList.remove('choreography-active');
                                                }, 1000);
                                            }, 4000);
                                        }, 2000);
                                    }, 3000);
                                }, 3000);
                            }, 1500);
                        }, 4000);
                    }, 5000);
                });
            }, 4000);
        }
        
        function slideshowTypewriter(callback) {
            const element = document.getElementById('slideshow-typewriter-sentence');
            element.textContent = '';
            charIndex = 0;
            
            function type() {
                if (charIndex < typewriterText.length) {
                    element.textContent += typewriterText.charAt(charIndex);
                    charIndex++;
                    setTimeout(type, 50);
                } else {
                    callback();
                }
            }
            type();
        }
        
        // Slideshow controls
        document.getElementById('skip-btn').addEventListener('click', function() {
            const slideshowOverlay = document.getElementById('slideshow-overlay');
            slideshowOverlay.style.transition = 'opacity 0.5s ease-out';
            slideshowOverlay.style.opacity = '0';
            
            setTimeout(() => {
                slideshowOverlay.style.display = 'none';
                document.body.classList.remove('choreography-active');
            }, 500);
            
            // Mark slideshow as seen
            sessionStorage.setItem('flanerie-slideshow-seen', 'true');
        });
        
        document.getElementById('pause-btn').addEventListener('click', function() {
            this.textContent = this.textContent === '‚è∏' ? '‚ñ∂' : '‚è∏';
        });
        
        document.getElementById('rewind-btn').addEventListener('click', function() {
            charIndex = 0;
            document.getElementById('slideshow-typewriter-sentence').textContent = '';
            // Reset all states
            document.querySelectorAll('.fading, .showing, .move-up, .fade-in').forEach(el => {
                el.classList.remove('fading', 'showing', 'move-up', 'fade-in');
            });
            startSlideshow();
        });
        
        // Only show slideshow once per browser session
        if (!sessionStorage.getItem('flanerie-slideshow-seen')) {
            startSlideshow();
            sessionStorage.setItem('flanerie-slideshow-seen', 'true');
        } else {
            // Skip slideshow - hide overlay immediately
            const slideshowOverlay = document.getElementById('slideshow-overlay');
            if (slideshowOverlay) {
                slideshowOverlay.style.display = 'none';
            }
        }
        
        // Rotating hero phrases
        let currentHeroTextIndex = 0;
        const heroTextSpans = document.querySelectorAll('.hero .rotating-text span');
        
        function rotateHeroText() {
            heroTextSpans[currentHeroTextIndex].classList.remove('active');
            currentHeroTextIndex = (currentHeroTextIndex + 1) % heroTextSpans.length;
            heroTextSpans[currentHeroTextIndex].classList.add('active');
        }
        
        setInterval(rotateHeroText, 3000);
        
        // Scroll to content
        function scrollToContent() {
            document.querySelector('.main-content').scrollIntoView({ behavior: 'smooth' });
        }
        
        function scrollToExplore() {
            document.getElementById('features-content').scrollIntoView({ behavior: 'smooth' });
        }
        
        // Scroll to any section by ID
        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.scrollIntoView({ behavior: 'smooth' });
            }
        }
        
        // Make globally accessible
        window.scrollToContent = scrollToContent;
        window.scrollToExplore = scrollToExplore;
        window.scrollToSection = scrollToSection;
        
        // === GPS LOCATION FEATURES (Mobile Only) ===
        
        // Detect if user is on mobile device
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        
        // Get user's current GPS location
        function getUserLocation(callback) {
            if (!navigator.geolocation) {
                showToast('‚ùå GPS not supported on this device');
                return;
            }
            
            showToast('üìç Getting your location...');
            
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    callback({ lat, lng });
                },
                (error) => {
                    let message = '‚ùå Could not get your location';
                    if (error.code === error.PERMISSION_DENIED) {
                        message = '‚ùå Location permission denied. Enable in settings.';
                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                        message = '‚ùå Location unavailable. Check GPS settings.';
                    } else if (error.code === error.TIMEOUT) {
                        message = '‚ùå Location request timed out. Try again.';
                    }
                    showToast(message);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }
        
        // GPS button for Journey mode (adds waypoint at current location)
        function useMyLocationForJourney() {
            getUserLocation((coords) => {
                const latlng = { lat: coords.lat, lng: coords.lng };
                addWaypoint(latlng);
                journeyMap.setView([coords.lat, coords.lng], 16);
                showToast('‚úÖ Waypoint added at your location!');
            });
        }
        
        // GPS button for Swarm mode (places pin at current location)
        function useMyLocationForSwarm() {
            getUserLocation((coords) => {
                // Simulate a map click at the GPS coordinates
                const latlng = { lat: coords.lat, lng: coords.lng };
                
                // Same logic as addSwarmMarker function
                if (swarmMarkers.length > 0) {
                    swarmMarkers.forEach(marker => journeyMap.removeLayer(marker));
                    swarmMarkers = [];
                }
                
                if (swarmLocations.length >= 5) {
                    showToast('Maximum 5 locations reached');
                    return;
                }
                
                const marker = L.marker(latlng).addTo(journeyMap);
                swarmMarkers.push(marker);
                swarmLocations.push({ lat: coords.lat, lng: coords.lng });
                journeyMap.setView([coords.lat, coords.lng], 16);
                
                const saveBtn = document.getElementById('saveSwarmMapBtn');
                if (saveBtn) saveBtn.disabled = false;
                
                document.getElementById('multiBusinessContainer').style.display = 'block';
                
                createSwarmBusinessLabel(swarmLocations.length);
                
                showToast(`üìç Location ${swarmLocations.length} pinned at your location!`);
            });
        }
        
        // GPS button for Event mode (places pin at current location)
        function useMyLocationForEvent() {
            getUserLocation((coords) => {
                // Same logic as clicking the map in event mode
                const latlng = { lat: coords.lat, lng: coords.lng };
                
                if (window.eventMarker) {
                    journeyMap.removeLayer(window.eventMarker);
                }
                
                // Create custom pin icon to match event style
                const eventPinIcon = L.divIcon({
                    className: 'event-marker-pin',
                    html: '<div style="background: #0056b3; color: white; border-radius: 50% 50% 50% 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; transform: rotate(-45deg); box-shadow: 0 2px 8px rgba(0,0,0,0.3);"><span style="transform: rotate(45deg);">üìç</span></div>',
                    iconSize: [32, 32],
                    iconAnchor: [16, 32]
                });
                
                window.eventMarker = L.marker([coords.lat, coords.lng], { icon: eventPinIcon }).addTo(journeyMap);
                
                // Store location with reverse geocoding for address
                reverseGeocode(coords.lat, coords.lng).then(address => {
                    window.eventLocation = { 
                        lat: coords.lat, 
                        lng: coords.lng,
                        address: address
                    };
                });
                
                journeyMap.setView([coords.lat, coords.lng], 16);
                
                const saveBtn = document.getElementById('saveEventMapBtn');
                if (saveBtn) saveBtn.disabled = false;
                
                showToast('‚úÖ Event location pinned at your location!');
            });
        }
        
        // Route GPS button click to appropriate function based on mode
        function handleGPSClick(mode) {
            if (mode === 'journey') {
                useMyLocationForJourney();
            } else if (mode === 'swarm') {
                useMyLocationForSwarm();
            } else if (mode === 'event') {
                useMyLocationForEvent();
            }
        }
        
        // Make GPS functions globally accessible
        window.isMobileDevice = isMobileDevice;
        window.useMyLocationForJourney = useMyLocationForJourney;
        window.useMyLocationForSwarm = useMyLocationForSwarm;
        window.useMyLocationForEvent = useMyLocationForEvent;
        window.handleGPSClick = handleGPSClick;
    </script>
    
    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    
    <script>
        // ===== FIREBASE CONFIGURATION =====
        const firebaseConfig = {
            apiKey: "AIzaSyB4nznaJQ1VGNDylnfN5J9MW74Thm8XoS8",
            authDomain: "flanerie-70dfd.firebaseapp.com",
            databaseURL: "https://flanerie-70dfd-default-rtdb.firebaseio.com",
            projectId: "flanerie-70dfd",
            storageBucket: "flanerie-70dfd.firebasestorage.app",
            messagingSenderId: "367532686554",
            appId: "1:367532686554:web:0373f528284844cf5e79e3"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        window.database = firebase.database();
        const database = window.database; // Keep local reference for this script block
        
        // Initialize Firebase Auth
        window.auth = firebase.auth();
        const auth = window.auth;
        
        // ===== FIREBASE AUTHENTICATION =====
        
        // ===== SITE LOCKDOWN (Remove this section when ready to launch) =====
        // This blocks the entire site until an authorized user logs in
        // ONLY ACTIVATES ON PRODUCTION SITES - GitHub Pages remains open for testing
        if (window.location.hostname.includes('firebaseapp.com') || 
            window.location.hostname.includes('web.app') || 
            window.location.hostname.includes('pages.dev')) {
            const lockdownOverlay = document.createElement('div');
            lockdownOverlay.id = 'lockdown-overlay';
            lockdownOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
                z-index: 999999;
                display: flex;
                align-items: center;
                justify-content: center;
                font-family: 'Poppins', sans-serif;
            `;
            lockdownOverlay.innerHTML = `
                <div style="text-align: center; padding: 3rem; background: rgba(25, 25, 25, 0.95); border-radius: 20px; border: 2px solid rgba(107, 155, 158, 0.3); max-width: 500px;">
                    <h1 style="color: #8DBCC0; font-family: 'Playfair Display', serif; font-size: 3rem; margin-bottom: 1rem;">Fl√¢nerie</h1>
                    <p style="color: #8DBCC0; margin-bottom: 2rem; font-size: 1.1rem;">Admin Access Only</p>
                    <p style="color: #999; margin-bottom: 2rem;">This site is currently in private testing.</p>
                    <button id="admin-login-btn" style="background: linear-gradient(135deg, #6B9B9E, #8dbcc0); color: white; border: none; padding: 1rem 2rem; border-radius: 25px; font-size: 1.1rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; display: inline-flex; align-items: center; gap: 0.5rem;">
                        <span style="font-size: 1.3rem;">G</span> Sign in with Google
                    </button>
                </div>
            `;
            document.body.appendChild(lockdownOverlay);
            
            // Handle admin login button
            document.getElementById('admin-login-btn').addEventListener('click', function() {
                const provider = new firebase.auth.GoogleAuthProvider();
                auth.signInWithPopup(provider).catch(function(error) {
                    console.error('Login error:', error);
                    alert('Login failed: ' + error.message);
                });
            });
        }
        // ===== END SITE LOCKDOWN =====
        
        // Auth state listener - runs when user signs in/out
        auth.onAuthStateChanged(async function(user) {
            if (user) {
                // AUTHORIZED USERS ONLY - Only checked on Firebase, not GitHub Pages
                if (window.location.hostname.includes('firebaseapp.com') || window.location.hostname.includes('web.app')) {
                    const authorizedEmails = [
                        'highdefpants@gmail.com',  // Replace with your actual email
                        // 'friend@gmail.com',    // Uncomment and add more emails as needed
                    ];
                    
                    // Check if user is authorized
                    if (!authorizedEmails.includes(user.email)) {
                        // NOT AUTHORIZED - Sign them out and show error
                        await auth.signOut();
                        alert('Access denied. This site is currently in private testing. Your email (' + user.email + ') is not authorized.');
                        return;
                    }
                }
                
                // User is signed in AND authorized (or on GitHub Pages)
                console.log('User signed in:', user.email);
                console.log('User displayName:', user.displayName);
                console.log('User UID:', user.uid);
                
                // Remove lockdown overlay - site is now accessible
                const overlay = document.getElementById('lockdown-overlay');
                if (overlay) {
                    overlay.remove();
                }
                
                // Get username from database or use displayName
                let username = await getUsernameFromId(user.uid);
                console.log('Username from getUsernameFromId:', username);
                
                // If no username set up yet, use displayName or email prefix
                if (username === 'Unknown User') {
                    if (user.displayName) {
                        username = user.displayName;
                        console.log('Using displayName as fallback:', username);
                    } else if (user.email) {
                        // Use email prefix as temporary display
                        username = user.email.split('@')[0];
                        console.log('Using email prefix as fallback:', username);
                    }
                }
                
                console.log('Final username to display:', username);
                
                // Update UI
                document.getElementById('sign-in-btn').style.display = 'none';
                document.getElementById('user-info').style.display = 'flex';
                
                // Show username instead of email
                document.getElementById('user-name').textContent = `Hi, ${username}!`;
                
                // Force layout recalculation on mobile (fixes alignment after login)
                const navContainer = document.querySelector('.nav-container');
                if (navContainer) {
                    void navContainer.offsetHeight; // Force reflow
                }
                
                // Check if user is banned
                const isBanned = await checkIfBanned();
                if (isBanned) {
                    // Show suspension banner
                    showSuspensionBanner();
                    // Hide all create/action buttons
                    disableUserActions();
                } else {
                    // Hide suspension banner
                    hideSuspensionBanner();
                    // Enable all buttons
                    enableUserActions();
                }
                
                // Show verification banner if email not verified (only for email/password users)
                const isEmailPasswordUser = user.providerData[0].providerId === 'password';
                const verificationBanner = document.getElementById('verification-banner');
                if (isEmailPasswordUser && !user.emailVerified) {
                    verificationBanner.style.display = 'block';
                    startVerificationAutoCheck();
                } else {
                    verificationBanner.style.display = 'none';
                    if (verificationCheckInterval) {
                        clearInterval(verificationCheckInterval);
                        verificationCheckInterval = null;
                    }
                }
                
                // Close sign-in modal if open
                closeSignInModal();
            } else {
                // User is signed out
                console.log('User signed out');
                
                // Update UI
                document.getElementById('sign-in-btn').style.display = 'block';
                document.getElementById('user-info').style.display = 'none';
                
                // Force layout recalculation on mobile
                const navContainer = document.querySelector('.nav-container');
                if (navContainer) {
                    void navContainer.offsetHeight; // Force reflow
                }
                
                // Hide verification banner
                document.getElementById('verification-banner').style.display = 'none';
                
                // Hide suspension banner
                hideSuspensionBanner();
            }
        });
        
        // Refresh auth state when user returns to tab (to detect email verification)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && auth.currentUser) {
                auth.currentUser.reload().then(() => {
                    const user = auth.currentUser;
                    const isEmailPasswordUser = user.providerData[0].providerId === 'password';
                    const verificationBanner = document.getElementById('verification-banner');
                    
                    if (isEmailPasswordUser && !user.emailVerified) {
                        if (verificationBanner.style.display === 'none') {
                            verificationBanner.style.display = 'block';
                            startVerificationAutoCheck();
                        }
                    } else {
                        if (verificationBanner.style.display !== 'none') {
                            verificationBanner.style.display = 'none';
                            showToast('‚úÖ Email verified! You can now start posting.');
                        }
                    }
                }).catch(error => {
                    console.error('Error reloading user:', error);
                });
            }
        });
        
        // Auto-check verification status every 2 seconds when banner is visible
        let verificationCheckInterval = null;
        
        function startVerificationAutoCheck() {
            if (verificationCheckInterval) {
                clearInterval(verificationCheckInterval);
            }
            
            verificationCheckInterval = setInterval(() => {
                const user = auth.currentUser;
                const verificationBanner = document.getElementById('verification-banner');
                
                if (!user || verificationBanner.style.display === 'none') {
                    clearInterval(verificationCheckInterval);
                    verificationCheckInterval = null;
                    return;
                }
                
                user.reload().then(() => {
                    const updatedUser = auth.currentUser;
                    
                    if (updatedUser.emailVerified) {
                        verificationBanner.style.display = 'none';
                        clearInterval(verificationCheckInterval);
                        verificationCheckInterval = null;
                        showToast('‚úÖ Email verified! You can now start posting.');
                    }
                }).catch(error => {
                    console.error('Auto-check verification error:', error);
                });
            }, 2000); // Check every 2 seconds
        }
        
        // Start auto-check when banner becomes visible
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.target.id === 'verification-banner') {
                    const banner = mutation.target;
                    if (banner.style.display === 'block' && auth.currentUser && !auth.currentUser.emailVerified) {
                        startVerificationAutoCheck();
                    }
                }
            });
        });
        
        // Observe the banner for style changes
        const verificationBanner = document.getElementById('verification-banner');
        if (verificationBanner) {
            observer.observe(verificationBanner, { 
                attributes: true, 
                attributeFilter: ['style'] 
            });
        }
        
        // Sign in with Google
        function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider)
                .then((result) => {
                    showToast('Welcome to Fl√¢nerie!');
                })
                .catch((error) => {
                    console.error('Google sign-in error:', error);
                    showToast('Error signing in with Google');
                });
        }
        
        // Sign in with Email/Password
        function signInWithEmail(event) {
            event.preventDefault();
            
            const email = document.getElementById('signInEmail').value;
            const password = document.getElementById('signInPassword').value;
            
            auth.signInWithEmailAndPassword(email, password)
                .then(() => {
                    showToast('Welcome back!');
                })
                .catch((error) => {
                    console.error('Sign-in error:', error);
                    if (error.code === 'auth/user-not-found') {
                        showToast('No account found with this email');
                    } else if (error.code === 'auth/wrong-password') {
                        showToast('Incorrect password');
                    } else {
                        showToast('Error signing in');
                    }
                });
        }
        
        // Sign up with Email/Password
        async function signUpWithEmail(event) {
            event.preventDefault();
            
            // ANTI-BOT CHECK 1: Honeypot field
            const honeypot = document.getElementById('website').value;
            if (honeypot) {
                console.log('Bot detected: honeypot filled');
                showToast('Error creating account');
                return; // Bot detected, silently reject
            }
            
            // ANTI-BOT CHECK 2: Rate limiting (max 3 signups per hour from this browser)
            const signupAttempts = JSON.parse(localStorage.getItem('signupAttempts') || '[]');
            const now = Date.now();
            const oneHourAgo = now - (60 * 60 * 1000);
            const recentAttempts = signupAttempts.filter(time => time > oneHourAgo);
            
            if (recentAttempts.length >= 3) {
                showToast('Too many signup attempts. Please try again later.');
                return;
            }
            
            const email = document.getElementById('signUpEmail').value;
            const password = document.getElementById('signUpPassword').value;
            const displayName = document.getElementById('signUpDisplayName').value.trim();
            
            // Validate username format
            if (!/^[a-zA-Z0-9_]+$/.test(displayName)) {
                showToast('Username can only contain letters, numbers, and underscores');
                return;
            }
            
            if (displayName.length < 3 || displayName.length > 20) {
                showToast('Username must be 3-20 characters');
                return;
            }
            
            // Check username availability one more time
            const usernameLower = displayName.toLowerCase();
            const usernameCheck = await database.ref('usernames/' + usernameLower).once('value');
            if (usernameCheck.exists()) {
                showToast('Username is already taken!');
                return;
            }
            
            // Create account
            auth.createUserWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    const user = userCredential.user;
                    
                    // Record signup attempt
                    recentAttempts.push(now);
                    localStorage.setItem('signupAttempts', JSON.stringify(recentAttempts));
                    
                    // Set display name
                    return user.updateProfile({
                        displayName: displayName
                    }).then(() => {
                        // Save username to database (in usernames mapping only)
                        return database.ref('usernames/' + usernameLower).set(user.uid);
                    }).then(() => {
                        // Send verification email
                        console.log('Sending verification email to:', user.email);
                        return user.sendEmailVerification();
                    });
                })
                .then(() => {
                    console.log('Sign-up complete, verification email sent');
                    showToast('Account created! Please verify your email to unlock all features.');
                    // Update greeting with username immediately
                    document.getElementById('user-name').textContent = `Hi, ${displayName}!`;
                })
                .catch((error) => {
                    console.error('Sign-up error:', error);
                    if (error.code === 'auth/email-already-in-use') {
                        showToast('Email already in use');
                    } else if (error.code === 'auth/weak-password') {
                        showToast('Password must be at least 6 characters');
                    } else {
                        showToast('Error creating account');
                    }
                });
        }
        
        // Check username availability (live)
        let usernameCheckTimeout = null;
        async function checkUsernameAvailability() {
            const usernameInput = document.getElementById('signUpDisplayName');
            const statusElement = document.getElementById('usernameStatus');
            const username = usernameInput.value.trim();
            
            // Clear previous timeout
            if (usernameCheckTimeout) {
                clearTimeout(usernameCheckTimeout);
            }
            
            // Validate format
            if (username.length === 0) {
                statusElement.textContent = '';
                statusElement.style.color = '#999';
                return;
            }
            
            if (username.length < 3) {
                statusElement.textContent = '‚úó Too short (min 3 characters)';
                statusElement.style.color = '#d9534f';
                return;
            }
            
            if (username.length > 20) {
                statusElement.textContent = '‚úó Too long (max 20 characters)';
                statusElement.style.color = '#d9534f';
                return;
            }
            
            if (!/^[a-zA-Z0-9_]+$/.test(username)) {
                statusElement.textContent = '‚úó Only letters, numbers, and underscore allowed';
                statusElement.style.color = '#d9534f';
                return;
            }
            
            // Show checking status
            statusElement.textContent = '‚è≥ Checking...';
            statusElement.style.color = '#999';
            
            // Debounce the database check
            usernameCheckTimeout = setTimeout(async () => {
                try {
                    // Check if database is initialized
                    if (!database) {
                        console.error('Firebase database not initialized');
                        statusElement.textContent = '‚ö† Database not connected';
                        statusElement.style.color = '#d9534f';
                        return;
                    }
                    
                    const usernameLower = username.toLowerCase();
                    console.log('Checking username:', usernameLower);
                    const snapshot = await database.ref('usernames/' + usernameLower).once('value');
                    
                    if (snapshot.exists()) {
                        statusElement.textContent = '‚úó Username already taken';
                        statusElement.style.color = '#d9534f';
                    } else {
                        statusElement.textContent = '‚úì Username available!';
                        statusElement.style.color = 'var(--accent-color)';
                    }
                } catch (error) {
                    console.error('Error checking username:', error);
                    console.error('Error details:', error.message, error.code);
                    statusElement.textContent = '‚ö† Error: ' + (error.message || 'Connection failed');
                    statusElement.style.color = '#d9534f';
                }
            }, 500); // Wait 500ms after user stops typing
        }
        
        // Password reset functions
        function showForgotPasswordModal() {
            document.getElementById('signInModal').style.display = 'none';
            document.getElementById('forgotPasswordModal').style.display = 'flex';
        }
        
        function closeForgotPasswordModal() {
            document.getElementById('forgotPasswordModal').style.display = 'none';
            document.getElementById('forgotPasswordForm').reset();
        }
        
        function sendPasswordResetEmail(event) {
            event.preventDefault();
            const email = document.getElementById('resetEmail').value;
            
            auth.sendPasswordResetEmail(email)
                .then(() => {
                    showToast('Password reset email sent! Check your inbox.');
                    closeForgotPasswordModal();
                })
                .catch((error) => {
                    console.error('Password reset error:', error);
                    if (error.code === 'auth/user-not-found') {
                        showToast('No account found with this email');
                    } else {
                        showToast('Error sending reset email');
                    }
                });
        }
        
        // Sign out
        function signOut() {
            auth.signOut()
                .then(() => {
                    showToast('Signed out successfully');
                })
                .catch((error) => {
                    console.error('Sign-out error:', error);
                    showToast('Error signing out');
                });
        }
        
        // Modal controls
        function showSignInModal() {
            document.getElementById('signInModal').style.display = 'flex';
        }
        
        function closeSignInModal() {
            document.getElementById('signInModal').style.display = 'none';
            // Reset forms
            document.getElementById('signInForm').reset();
            document.getElementById('signUpForm').reset();
        }
        
        // Check if user can create content (signed in AND email verified)
        function checkAuthAndVerification() {
            const user = auth.currentUser;
            
            if (!user) {
                // Not signed in
                showSignInModal();
                return false;
            }
            
            if (!user.emailVerified && user.providerData[0].providerId === 'password') {
                // Email not verified (only check for email/password, not Google)
                showToast('Please verify your email before posting. Check your inbox!');
                return false;
            }
            
            return true;
        }
        
        // Resend verification email
        function resendVerificationEmail() {
            const user = auth.currentUser;
            if (user && !user.emailVerified) {
                console.log('Attempting to send verification email to:', user.email);
                user.sendEmailVerification()
                    .then(() => {
                        console.log('Verification email sent successfully');
                        showToast('Verification email sent! Check your inbox.');
                    })
                    .catch((error) => {
                        console.error('Error sending verification:', error);
                        console.error('Error code:', error.code);
                        console.error('Error message:', error.message);
                        showToast('Error: ' + (error.message || 'Failed to send verification email'));
                    });
            } else if (user && user.emailVerified) {
                console.log('User is already verified');
                showToast('Email already verified!');
            } else {
                console.error('No user found');
                showToast('Please sign in first');
            }
        }
        
        // Check verification status manually
        function checkVerificationStatus() {
            const user = auth.currentUser;
            if (!user) {
                showToast('Please sign in first');
                return;
            }
            
            showToast('Checking verification status...');
            user.reload().then(() => {
                const updatedUser = auth.currentUser;
                const verificationBanner = document.getElementById('verification-banner');
                
                if (updatedUser.emailVerified) {
                    verificationBanner.style.display = 'none';
                    showToast('‚úÖ Email verified! You can now start posting.');
                } else {
                    showToast('Email not yet verified. Please check your inbox and click the link.');
                }
            }).catch((error) => {
                console.error('Error checking verification:', error);
                showToast('Error checking verification status');
            });
        }
        window.checkVerificationStatus = checkVerificationStatus;
        
        // Switch between Sign In and Sign Up tabs
        function switchAuthTab(tab) {
            const signInTab = document.getElementById('signInTab');
            const signUpTab = document.getElementById('signUpTab');
            const signInForm = document.getElementById('signInForm');
            const signUpForm = document.getElementById('signUpForm');
            
            if (tab === 'signin') {
                signInTab.style.borderBottomColor = 'var(--accent-color)';
                signInTab.style.color = 'var(--accent-light)';
                signUpTab.style.borderBottomColor = 'transparent';
                signUpTab.style.color = '#999';
                signInForm.style.display = 'block';
                signUpForm.style.display = 'none';
            } else {
                signUpTab.style.borderBottomColor = 'var(--accent-color)';
                signUpTab.style.color = 'var(--accent-light)';
                signInTab.style.borderBottomColor = 'transparent';
                signInTab.style.color = '#999';
                signUpForm.style.display = 'block';
                signInForm.style.display = 'none';
            }
        }
        
        // Make functions globally accessible
        window.signInWithGoogle = signInWithGoogle;
        window.signInWithEmail = signInWithEmail;
        window.signUpWithEmail = signUpWithEmail;
        window.signOut = signOut;
        window.showSignInModal = showSignInModal;
        window.closeSignInModal = closeSignInModal;
        window.switchAuthTab = switchAuthTab;
        window.checkAuthAndVerification = checkAuthAndVerification;
        window.resendVerificationEmail = resendVerificationEmail;
        window.checkUsernameAvailability = checkUsernameAvailability;
        window.showForgotPasswordModal = showForgotPasswordModal;
        window.closeForgotPasswordModal = closeForgotPasswordModal;
        window.sendPasswordResetEmail = sendPasswordResetEmail;
        
        // ===== DASHBOARD FUNCTIONS =====
        
        // Open dashboard
        async function openDashboard() {
            const user = auth.currentUser;
            if (!user) {
                showSignInModal();
                return;
            }
            
            // Lock background scrolling
            document.body.classList.add('choreography-active');
            
            document.getElementById('dashboardModal').style.display = 'flex';
            updateUnreadBadge(); // Update message badge
            switchDashboardTab('routes');
        }
        
        // Close dashboard
        function closeDashboard() {
            // Unlock background scrolling
            document.body.classList.remove('choreography-active');
            
            document.getElementById('dashboardModal').style.display = 'none';
        }
        
        // Switch dashboard tabs
        function switchDashboardTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.dashboard-tab').forEach(btn => {
                btn.style.color = '#999';
                btn.style.borderBottom = '3px solid transparent';
            });
            document.getElementById(tab + 'Tab').style.color = 'var(--accent-light)';
            document.getElementById(tab + 'Tab').style.borderBottom = '3px solid var(--accent-color)';
            
            // Update content sections
            document.querySelectorAll('.dashboard-section').forEach(section => {
                section.style.display = 'none';
            });
            document.getElementById(tab + 'Content').style.display = 'block';
            
            // Load content based on tab
            if (tab === 'routes') {
                loadMyRoutes();
            } else if (tab === 'drafts') {
                loadMyDrafts();
            } else if (tab === 'swarms') {
                loadMySwarms();
            } else if (tab === 'events') {
                loadMyEvents();
            } else if (tab === 'likes') {
                loadMyLikes();
            } else if (tab === 'messages') {
                loadMyMessages();
            } else if (tab === 'account') {
                loadAccountSettings();
            }
        }
        
        // Load user's routes
        async function loadMyRoutes() {
            const user = auth.currentUser;
            if (!user) return;
            
            // Clean up deleted routes (6+ months old)
            cleanupDeletedRoutes();
            
            const contentDiv = document.getElementById('routesContent');
            contentDiv.innerHTML = '<p style="text-align: center; color: #999;">Loading...</p>';
            
            try {
                const snapshot = await database.ref('routes').orderByChild('createdBy').equalTo(user.uid).once('value');
                const routes = [];
                snapshot.forEach(child => {
                    const route = child.val();
                    // Exclude soft-deleted routes
                    if (!route.deleted) {
                        routes.push({ id: child.key, ...route });
                    }
                });
                
                if (routes.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #999;">You haven\'t created any routes yet.</p>';
                    return;
                }
                
                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1.5rem;">';
                routes.forEach(route => {
                    html += `
                        <div style="background: rgba(30, 30, 30, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; padding: 1.5rem;">
                            <h3 style="color: var(--accent-light); margin-bottom: 0.5rem;">${route.name}</h3>
                            <p style="color: #d4d4d4; font-size: 0.9rem; margin-bottom: 0.5rem;">${route.description || 'No description'}</p>
                            <p style="color: #999; font-size: 0.85rem; margin-bottom: 1rem;">
                                üìç ${route.waypointCount} waypoints<br>
                                üóÇÔ∏è ${route.category || 'Uncategorized'}<br>
                                ‚ù§Ô∏è ${route.likes || 0} fl√¢neurs like this route<br>
                                üìÖ ${new Date(route.created).toLocaleDateString()}
                            </p>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="viewRouteFromDashboard('${route.id}')" style="flex: 1; padding: 0.5rem; background: var(--accent-color); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">View on Map</button>
                                <button onclick="editRoute('${route.id}')" style="padding: 0.5rem 1rem; background: #5bc0de; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">Edit</button>
                                <button onclick="deleteRoute('${route.id}')" style="padding: 0.5rem 1rem; background: #d9534f; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">Delete</button>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                contentDiv.innerHTML = html;
            } catch (error) {
                console.error('Error loading routes:', error);
                contentDiv.innerHTML = '<p style="text-align: center; color: #d9534f;">Error loading routes</p>';
            }
        }
        
        // Load user's swarms
        async function loadMySwarms() {
            const user = auth.currentUser;
            if (!user) return;
            
            const contentDiv = document.getElementById('swarmsContent');
            contentDiv.innerHTML = '<p style="text-align: center; color: #999;">Loading...</p>';
            
            try {
                const snapshot = await database.ref('swarms').orderByChild('createdBy').equalTo(user.uid).once('value');
                const swarms = [];
                snapshot.forEach(child => {
                    swarms.push({ id: child.key, ...child.val() });
                });
                
                if (swarms.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #999;">You haven\'t created any swarms yet.</p>';
                    return;
                }
                
                const today = new Date();
                const now = new Date();
                
                // Filter out swarms that are past (with 2-hour buffer)
                const activeSwarms = swarms.filter(swarm => {
                    if (swarm.date && swarm.time) {
                        const [year, month, day] = swarm.date.split('-');
                        const [hours, minutes] = swarm.time.split(':');
                        const swarmDateTime = new Date(year, month - 1, day, hours, minutes);
                        const swarmEndWithBuffer = new Date(swarmDateTime.getTime() + 7200000); // 2 hour buffer
                        return swarmEndWithBuffer >= now;
                    } else if (swarm.date) {
                        const swarmDate = new Date(swarm.date);
                        swarmDate.setHours(0, 0, 0, 0);
                        return swarmDate >= today;
                    }
                    return true; // Keep swarms without dates
                });
                
                if (activeSwarms.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #999;">You haven\'t created any active swarms.<br><span style="font-size: 0.85rem; color: #777;">(Past swarms are automatically hidden)</span></p>';
                    return;
                }
                
                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1.5rem;">';
                activeSwarms.forEach(swarm => {
                    html += `
                        <div style="background: rgba(30, 30, 30, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; padding: 1.5rem;">
                            <h3 style="color: var(--accent-light); margin-bottom: 0.5rem;">${swarm.title}</h3>
                            <p style="color: #d4d4d4; font-size: 0.9rem; margin-bottom: 0.5rem;">${swarm.description || 'No description'}</p>
                            <p style="color: #999; font-size: 0.85rem; margin-bottom: 1rem;">
                                üìç ${swarm.locationCount || 1} location${swarm.locationCount > 1 ? 's' : ''}<br>
                                üìÖ ${swarm.date} at ${swarm.time}<br>
                                üë• ${swarm.interested || 0} fl√¢neurs interested<br>
                                ‚è±Ô∏è ${swarm.duration || 'TBD'}
                            </p>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="viewSwarmFromDashboard('${swarm.id}')" style="flex: 1; padding: 0.5rem; background: var(--accent-color); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">View on Map</button>
                                <button onclick="editSwarm('${swarm.id}')" style="padding: 0.5rem 1rem; background: #5bc0de; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">Edit</button>
                                <button onclick="deleteSwarm('${swarm.id}')" style="padding: 0.5rem 1rem; background: #d9534f; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">Delete</button>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                contentDiv.innerHTML = html;
            } catch (error) {
                console.error('Error loading swarms:', error);
                contentDiv.innerHTML = '<p style="text-align: center; color: #d9534f;">Error loading swarms</p>';
            }
        }
        
        // Load user's events
        async function loadMyEvents() {
            const user = auth.currentUser;
            if (!user) return;
            
            const contentDiv = document.getElementById('eventsContent');
            contentDiv.innerHTML = '<p style="text-align: center; color: #999;">Loading...</p>';
            
            try {
                const snapshot = await database.ref('events').orderByChild('createdBy').equalTo(user.uid).once('value');
                const events = [];
                snapshot.forEach(child => {
                    events.push({ id: child.key, ...child.val() });
                });
                
                if (events.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #999;">You haven\'t created any events yet.</p>';
                    return;
                }
                
                const today = new Date();
                const now = new Date();
                today.setHours(0, 0, 0, 0);
                
                // Filter out events that are past (with 2-hour buffer)
                const activeEvents = events.filter(event => {
                    if (event.endDate && event.endTime) {
                        const [year, month, day] = event.endDate.split('-');
                        const [hours, minutes] = event.endTime.split(':');
                        const endDateTime = new Date(year, month - 1, day, hours, minutes);
                        const endWithBuffer = new Date(endDateTime.getTime() + 7200000); // 2 hour buffer
                        return endWithBuffer >= now;
                    } else if (event.endDate) {
                        const [year, month, day] = event.endDate.split('-');
                        const endDate = new Date(year, month - 1, day, 23, 59, 59);
                        const endWithBuffer = new Date(endDate.getTime() + 7200000);
                        return endWithBuffer >= now;
                    } else if (event.startDate && event.startTime) {
                        const [year, month, day] = event.startDate.split('-');
                        const [hours, minutes] = event.startTime.split(':');
                        const startDateTime = new Date(year, month - 1, day, hours, minutes);
                        const startWithBuffer = new Date(startDateTime.getTime() + 7200000);
                        return startWithBuffer >= now;
                    } else if (event.startDate) {
                        const eventDate = new Date(event.startDate);
                        eventDate.setHours(23, 59, 59);
                        const eventWithBuffer = new Date(eventDate.getTime() + 7200000);
                        return eventWithBuffer >= now;
                    }
                    return true; // Keep events without dates
                });
                
                if (activeEvents.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #999;">You haven\'t created any active events.<br><span style="font-size: 0.85rem; color: #777;">(Past events are automatically hidden)</span></p>';
                    return;
                }
                
                let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1.5rem;">';
                activeEvents.forEach(event => {
                    // Show recurring badge if this is a recurring event
                    const recurringBadge = ''; // Recurring removed per user request
                    
                    html += `
                        <div style="background: rgba(30, 30, 30, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; padding: 1.5rem;">
                            <h3 style="color: var(--accent-light); margin-bottom: 0.5rem;">${event.name}${recurringBadge}</h3>
                            <p style="color: #d4d4d4; font-size: 0.9rem; margin-bottom: 0.5rem;">${event.description || 'No description'}</p>
                            ${event.recurrenceInfo ? `<p style="color: #999; font-size: 0.8rem; font-style: italic; margin-bottom: 0.5rem;">${event.recurrenceInfo}</p>` : ''}
                            <p style="color: #999; font-size: 0.85rem; margin-bottom: 1rem;">
                                üìç ${event.location}<br>
                                üìÖ ${event.startDate} at ${event.startTime}<br>
                                üë• ${event.interested || 0} fl√¢neurs interested
                            </p>
                            <div style="display: flex; gap: 0.5rem;">
                                <button onclick="viewEventFromDashboard('${event.id}')" style="flex: 1; padding: 0.5rem; background: var(--accent-color); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">View on Map</button>
                                <button onclick="editEvent('${event.id}')" style="padding: 0.5rem 1rem; background: #5bc0de; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">Edit</button>
                                <button onclick="deleteEvent('${event.id}')" style="padding: 0.5rem 1rem; background: #d9534f; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">Delete</button>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                contentDiv.innerHTML = html;
            } catch (error) {
                console.error('Error loading events:', error);
                contentDiv.innerHTML = '<p style="text-align: center; color: #d9534f;">Error loading events</p>';
            }
        }
        
        // Load user's likes
        async function loadMyLikes() {
            const contentDiv = document.getElementById('likesContent');
            contentDiv.innerHTML = '<div style="text-align: center; color: #999;"><p>Loading your likes...</p></div>';
            
            const user = auth.currentUser;
            if (!user) {
                contentDiv.innerHTML = '<p style="text-align: center; color: #d9534f;">Please sign in to view your likes</p>';
                return;
            }
            
            const userId = user.uid;
            const likedItems = [];
            
            try {
                // Get user's likes from Firebase
                const likesSnapshot = await database.ref(`userLikes/${userId}`).once('value');
                if (likesSnapshot.exists()) {
                    likesSnapshot.forEach((typeSnapshot) => {
                        const type = typeSnapshot.key; // routes, swarms, events
                        typeSnapshot.forEach((itemSnapshot) => {
                            const itemId = itemSnapshot.key;
                            likedItems.push({
                                action: 'liked',
                                type: type,
                                id: itemId
                            });
                        });
                    });
                }
                
                // Get user's interests from Firebase
                const interestsSnapshot = await database.ref(`userInterests/${userId}`).once('value');
                if (interestsSnapshot.exists()) {
                    interestsSnapshot.forEach((typeSnapshot) => {
                        const type = typeSnapshot.key; // swarms, events
                        typeSnapshot.forEach((itemSnapshot) => {
                            const itemId = itemSnapshot.key;
                            likedItems.push({
                                action: 'interested',
                                type: type,
                                id: itemId
                            });
                        });
                    });
                }
            } catch (error) {
                console.error('Error loading user likes:', error);
                contentDiv.innerHTML = '<p style="text-align: center; color: #d9534f;">Error loading likes</p>';
                return;
            }
            
            if (likedItems.length === 0) {
                contentDiv.innerHTML = '<p style="text-align: center; color: #999;">You haven\'t liked anything yet. Explore and like routes, swarms, or events!</p>';
                return;
            }
            
            // Fetch all liked items first
            const fetchedItems = [];
            for (const item of likedItems) {
                try {
                    const snapshot = await database.ref(`${item.type}/${item.id}`).once('value');
                    const data = snapshot.val();
                    if (data) {
                        fetchedItems.push({
                            ...item,
                            data: data
                        });
                    }
                } catch (error) {
                    console.error('Error loading liked item:', error);
                }
            }
            
            if (fetchedItems.length === 0) {
                contentDiv.innerHTML = '<p style="text-align: center; color: #999;">No liked items found.</p>';
                return;
            }
            
            // Now render all items
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1.5rem;">';
            
            fetchedItems.forEach(item => {
                const emoji = item.type === 'routes' ? 'üö∂' : item.type === 'swarms' ? 'üõçÔ∏è' : 'üéâ';
                const actionText = item.action === 'liked' ? 'Liked' : 'Interested in';
                const sectionMap = { 'routes': 'search', 'swarms': 'swarms', 'events': 'events' };
                
                html += `
                    <div onclick="closeDashboard(); toggleSection('${sectionMap[item.type]}', '${item.id}')" style="background: rgba(30, 30, 30, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; padding: 1.5rem; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.borderColor='var(--accent-color)'" onmouseout="this.style.borderColor='rgba(107, 155, 158, 0.3)'">
                        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                            <span style="font-size: 1.5rem;">${emoji}</span>
                            <span style="color: #999; font-size: 0.85rem;">${actionText}</span>
                        </div>
                        <h3 style="color: var(--accent-light); margin-bottom: 0.5rem;">${item.data.name || item.data.title}</h3>
                        <p style="color: #d4d4d4; font-size: 0.9rem; margin-bottom: 0;">${item.data.description || 'No description'}</p>
                    </div>
                `;
            });
            
            html += '</div>';
            contentDiv.innerHTML = html;
        }
        
        // Load user's messages
        async function loadMyMessages() {
            const contentDiv = document.getElementById('messagesContent');
            contentDiv.innerHTML = '<div style="text-align: center; color: #999;"><p>Loading your messages...</p></div>';
            
            const user = auth.currentUser;
            if (!user) {
                contentDiv.innerHTML = '<p style="text-align: center; color: #d9534f;">Please sign in to view your messages</p>';
                return;
            }
            
            // Clean up old messages (30+ days old for events/swarms)
            cleanupOldMessages();
            
            try {
                const messages = await loadMessages();
                
                if (messages.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #999;">No messages yet. When someone contacts you about your swarms or events, they\'ll appear here!</p>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 1rem;">';
                
                messages.forEach(msg => {
                    const isUnread = !msg.read;
                    const timestamp = new Date(msg.timestamp).toLocaleString();
                    
                    // Escape HTML to prevent XSS
                    const escapeHtml = (str) => {
                        if (!str) return '';
                        return String(str)
                            .replace(/&/g, '&amp;')
                            .replace(/</g, '&lt;')
                            .replace(/>/g, '&gt;')
                            .replace(/"/g, '&quot;')
                            .replace(/'/g, '&#039;');
                    };
                    
                    const escapedSubject = escapeHtml(msg.subject);
                    const escapedFromName = escapeHtml(msg.fromName);
                    const escapedFromEmail = escapeHtml(msg.fromEmail);
                    const escapedItemName = escapeHtml(msg.itemName);
                    const escapedType = escapeHtml(msg.type);
                    const escapedMessage = escapeHtml(msg.message);
                    
                    html += `
                        <div style="background: ${isUnread ? 'rgba(107, 155, 158, 0.15)' : 'rgba(30, 30, 30, 0.8)'}; border: 2px solid ${isUnread ? 'var(--accent-color)' : 'rgba(107, 155, 158, 0.3)'}; border-radius: 15px; padding: 1.5rem;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                                <div style="flex: 1;">
                                    ${isUnread ? '<span style="background: var(--accent-color); color: white; padding: 0.2rem 0.6rem; border-radius: 10px; font-size: 0.75rem; margin-right: 0.5rem; font-weight: 600;">NEW</span>' : ''}
                                    <span style="color: var(--accent-light); font-weight: 600; font-size: 1.1rem;">${escapedSubject}</span>
                                </div>
                                <button onclick="deleteMessage('${msg.id}')" style="background: rgba(255, 70, 70, 0.2); border: none; color: #ff4646; padding: 0.4rem 0.8rem; border-radius: 8px; cursor: pointer; font-size: 0.85rem; transition: all 0.2s;" onmouseover="this.style.background='rgba(255, 70, 70, 0.4)'" onmouseout="this.style.background='rgba(255, 70, 70, 0.2)'">Delete</button>
                            </div>
                            
                            <div style="color: #999; font-size: 0.85rem; margin-bottom: 0.8rem;">
                                <strong style="color: var(--accent-light);">From:</strong> ${escapedFromName} (${escapedFromEmail})<br>
                                <strong style="color: var(--accent-light);">About:</strong> ${escapedItemName} (${escapedType})<br>
                                <strong style="color: var(--accent-light);">Sent:</strong> ${timestamp}
                            </div>
                            
                            <div style="color: #d4d4d4; line-height: 1.6; white-space: pre-wrap; background: rgba(10, 10, 10, 0.5); padding: 1rem; border-radius: 10px; border-left: 3px solid var(--accent-color);">
                                ${escapedMessage}
                            </div>
                            
                            ${isUnread ? `<button onclick="markMessageRead('${msg.id}'); loadMyMessages();" style="background: var(--accent-color); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; cursor: pointer; margin-top: 1rem; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.transform='translateY(-2px)'" onmouseout="this.style.transform='translateY(0)'">Mark as Read</button>` : ''}
                            
                            <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem; flex-wrap: wrap;">
                                <button onclick="replyToMessage('${msg.from}', '${escapedFromName}', 'Re: ${escapedSubject}')" style="display: inline-block; background: rgba(107, 155, 158, 0.2); color: var(--accent-light); border: none; padding: 0.6rem 1.2rem; border-radius: 10px; cursor: pointer; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='rgba(107, 155, 158, 0.3)'" onmouseout="this.style.background='rgba(107, 155, 158, 0.2)'">üí¨ Reply</button>
                                <button onclick="reportMessage('${msg.id}', '${msg.from}', '${escapedSubject}')" style="background: rgba(255, 70, 70, 0.2); color: #ff4646; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; cursor: pointer; font-weight: 600; transition: all 0.2s;" onmouseover="this.style.background='rgba(255, 70, 70, 0.4)'" onmouseout="this.style.background='rgba(255, 70, 70, 0.2)'">üö© Report</button>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                contentDiv.innerHTML = html;
                
                // Update unread badge
                updateUnreadBadge();
                
            } catch (error) {
                console.error('Error loading messages:', error);
                contentDiv.innerHTML = '<p style="text-align: center; color: #d9534f;">Error loading messages</p>';
            }
        }
        
        // Update unread message badge
        async function updateUnreadBadge() {
            const count = await getUnreadMessageCount();
            const badge = document.getElementById('unreadBadge');
            if (badge) {
                if (count > 0) {
                    badge.textContent = count;
                    badge.style.display = 'inline';
                } else {
                    badge.style.display = 'none';
                }
            }
        }
        
        // Load account settings
        async function loadAccountSettings() {
            const user = auth.currentUser;
            if (!user) return;
            
            const contentDiv = document.getElementById('accountContent');
            
            // Get user creation date
            const creationDate = user.metadata.creationTime ? new Date(user.metadata.creationTime).toLocaleDateString('en-US', { year: 'numeric', month: 'long' }) : 'Unknown';
            
            contentDiv.innerHTML = `
                <div style="max-width: 600px; margin: 0 auto;">
                    <div style="text-align: center; padding: 2rem; background: rgba(30, 30, 30, 0.6); border-radius: 15px; margin-bottom: 2rem;">
                        <h3 style="color: var(--accent-light); margin-bottom: 0.5rem;">Fl√¢neur since ${creationDate}</h3>
                        <p style="color: #999; font-size: 0.9rem;">Welcome back, ${user.displayName || user.email.split('@')[0]}!</p>
                    </div>
                    
                    <div style="background: rgba(30, 30, 30, 0.6); border-radius: 15px; padding: 2rem; margin-bottom: 1.5rem;">
                        <h3 style="color: var(--accent-color); margin-bottom: 1.5rem;">Account Information</h3>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; color: #999; font-size: 0.85rem; margin-bottom: 0.5rem;">Username</label>
                            <div style="display: flex; gap: 1rem; align-items: center;">
                                <input type="text" id="usernameInput" value="${user.displayName || user.email.split('@')[0]}" style="flex: 1; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                                <button onclick="updateUsername()" style="padding: 0.8rem 1.5rem; background: var(--accent-color); border: none; border-radius: 10px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s;">Update</button>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; color: #999; font-size: 0.85rem; margin-bottom: 0.5rem;">Email</label>
                            <div style="display: flex; gap: 1rem; align-items: center;">
                                <input type="email" id="emailInput" value="${user.email}" style="flex: 1; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                                <button onclick="updateEmail()" style="padding: 0.8rem 1.5rem; background: var(--accent-color); border: none; border-radius: 10px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s;">Update</button>
                            </div>
                        </div>
                        
                        <div>
                            <label style="display: block; color: #999; font-size: 0.85rem; margin-bottom: 0.5rem;">Password</label>
                            <button onclick="updatePassword()" style="width: 100%; padding: 0.8rem; background: rgba(107, 155, 158, 0.2); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: var(--accent-light); font-weight: 600; cursor: pointer; transition: all 0.3s;">Change Password</button>
                        </div>
                    </div>
                    
                    <div style="background: rgba(50, 20, 20, 0.6); border: 2px solid rgba(220, 38, 38, 0.3); border-radius: 15px; padding: 2rem;">
                        <h3 style="color: #ff6b6b; margin-bottom: 1rem;">Danger Zone</h3>
                        <p style="color: #d4d4d4; margin-bottom: 1rem; font-size: 0.9rem;">Permanently delete your account and all associated data. This action cannot be undone.</p>
                        <button onclick="deleteAccount()" style="width: 100%; padding: 0.8rem; background: rgba(220, 38, 38, 0.2); border: 2px solid #dc2626; border-radius: 10px; color: #ff6b6b; font-weight: 600; cursor: pointer; transition: all 0.3s;">Delete My Account</button>
                    </div>
                </div>
            `;
        }
        
        // Update username
        async function updateUsername() {
            const user = auth.currentUser;
            if (!user) return;
            
            const newUsername = document.getElementById('usernameInput')?.value;
            if (!newUsername || newUsername.trim() === '') {
                showToast('Please enter a username');
                return;
            }
            
            // Validate username format
            if (!/^[a-zA-Z0-9_]+$/.test(newUsername)) {
                showToast('Username can only contain letters, numbers, and underscores');
                return;
            }
            
            if (newUsername.length < 3 || newUsername.length > 20) {
                showToast('Username must be 3-20 characters');
                return;
            }
            
            try {
                // Check if new username is already taken by someone else
                const newUsernameLower = newUsername.toLowerCase();
                const usernameCheck = await database.ref('usernames/' + newUsernameLower).once('value');
                if (usernameCheck.exists() && usernameCheck.val() !== user.uid) {
                    showToast('‚ùå Username is already taken!');
                    return;
                }
                
                // Find ALL old username entries for this user ID
                const allUsernamesSnap = await database.ref('usernames').once('value');
                const oldEntries = [];
                allUsernamesSnap.forEach((child) => {
                    if (child.val() === user.uid && child.key !== newUsernameLower) {
                        oldEntries.push(child.key);
                    }
                });
                
                console.log('Old username entries to remove:', oldEntries);
                
                // Remove ALL old entries concurrently
                if (oldEntries.length > 0) {
                    await Promise.all(
                        oldEntries.map(oldEntry => database.ref('usernames/' + oldEntry).remove())
                    );
                    console.log('Removed old entries:', oldEntries);
                }
                
                // Add new username mapping
                await database.ref('usernames/' + newUsernameLower).set(user.uid);
                console.log('Set new username:', newUsernameLower, '‚Üí', user.uid);
                
                // Update Firebase Auth displayName
                await user.updateProfile({ displayName: newUsername });
                console.log('Updated displayName to:', newUsername);
                
                // DON'T reload immediately - it might fetch old data before update propagates
                // The update is already applied locally
                
                // Verify the update worked
                const verifySnap = await database.ref('usernames').once('value');
                let foundEntries = [];
                verifySnap.forEach((child) => {
                    if (child.val() === user.uid) {
                        foundEntries.push(child.key);
                    }
                });
                console.log('Verification - usernames for this user:', foundEntries);
                
                // Update UI immediately
                document.getElementById('user-name').textContent = `Hi, ${newUsername}!`;
                
                showToast('‚úÖ Username updated successfully!');
                
                // Suggest refresh to see changes on routes
                setTimeout(() => {
                    showToast('üí° Refresh the page to see your new username on all your posts!');
                }, 2000);
                
            } catch (error) {
                console.error('Error updating username:', error);
                showToast('‚ùå Error: ' + (error.message || 'Unknown error'));
            }
        }
        
        // Update email
        async function updateEmail() {
            const user = auth.currentUser;
            if (!user) return;
            
            const newEmail = document.getElementById('emailInput')?.value;
            if (!newEmail || !newEmail.includes('@')) {
                showToast('Please enter a valid email');
                return;
            }
            
            try {
                await user.updateEmail(newEmail);
                
                // Send verification email to new address
                await user.sendEmailVerification();
                
                showToast('‚úÖ Email updated! Please verify your new email.');
                
                // Show verification banner if not verified
                const verificationBanner = document.getElementById('verification-banner');
                if (verificationBanner && !user.emailVerified) {
                    verificationBanner.style.display = 'block';
                    startVerificationAutoCheck();
                }
            } catch (error) {
                console.error('Error updating email:', error);
                if (error.code === 'auth/requires-recent-login') {
                    showToast('‚ùå Please sign out and sign in again before changing email');
                } else {
                    showToast('‚ùå Error updating email: ' + error.message);
                }
            }
        }
        
        // Update password
        async function updatePassword() {
            const user = auth.currentUser;
            if (!user) return;
            
            const newPassword = prompt('Enter your new password (minimum 6 characters):');
            if (!newPassword || newPassword.length < 6) {
                showToast('Password must be at least 6 characters');
                return;
            }
            
            try {
                await user.updatePassword(newPassword);
                showToast('‚úÖ Password updated successfully!');
            } catch (error) {
                console.error('Error updating password:', error);
                if (error.code === 'auth/requires-recent-login') {
                    showToast('‚ùå Please sign out and sign in again before changing password');
                } else {
                    showToast('‚ùå Error updating password: ' + error.message);
                }
            }
        }
        
        // Delete account
        async function deleteAccount() {
            const user = auth.currentUser;
            if (!user) return;
            
            const confirmation = prompt('This will permanently delete your account and all data. Type "DELETE" to confirm:');
            if (confirmation !== 'DELETE') {
                showToast('Account deletion cancelled');
                return;
            }
            
            try {
                // Delete user data from Firebase
                await database.ref(`routes`).orderByChild('createdBy').equalTo(user.uid).once('value', async (snapshot) => {
                    const deletePromises = [];
                    snapshot.forEach(child => {
                        deletePromises.push(database.ref(`routes/${child.key}`).remove());
                    });
                    await Promise.all(deletePromises);
                });
                
                await database.ref(`swarms`).orderByChild('createdBy').equalTo(user.uid).once('value', async (snapshot) => {
                    const deletePromises = [];
                    snapshot.forEach(child => {
                        deletePromises.push(database.ref(`swarms/${child.key}`).remove());
                    });
                    await Promise.all(deletePromises);
                });
                
                await database.ref(`events`).orderByChild('createdBy').equalTo(user.uid).once('value', async (snapshot) => {
                    const deletePromises = [];
                    snapshot.forEach(child => {
                        deletePromises.push(database.ref(`events/${child.key}`).remove());
                    });
                    await Promise.all(deletePromises);
                });
                
                // Delete user account
                await user.delete();
                showToast('Account deleted successfully');
                window.location.reload();
            } catch (error) {
                console.error('Error deleting account:', error);
                if (error.code === 'auth/requires-recent-login') {
                    showToast('‚ùå Please sign out and sign in again before deleting account');
                } else {
                    showToast('‚ùå Error deleting account: ' + error.message);
                }
            }
        }
        
        window.loadAccountSettings = loadAccountSettings;
        window.updateUsername = updateUsername;
        window.updateEmail = updateEmail;
        window.updatePassword = updatePassword;
        window.deleteAccount = deleteAccount;
        
        // View items from dashboard on map
        
        // Delete route
        async function deleteRoute(routeId) {
            if (!confirm('Are you sure you want to delete this route? It will be hidden but recoverable for 6 months.')) {
                return;
            }
            
            try {
                // Soft delete - mark as deleted but keep in database
                await database.ref(`routes/${routeId}`).update({
                    deleted: true,
                    deletedAt: new Date().toISOString()
                });
                showToast('Route deleted successfully');
                loadMyRoutes();
            } catch (error) {
                console.error('Error deleting route:', error);
                showToast('Error deleting route');
            }
        }
        
        // Delete swarm
        async function deleteSwarm(swarmId) {
            if (!confirm('Are you sure you want to delete this swarm? This cannot be undone.')) {
                return;
            }
            
            try {
                await database.ref(`swarms/${swarmId}`).remove();
                showToast('Swarm deleted successfully');
                loadMySwarms();
            } catch (error) {
                console.error('Error deleting swarm:', error);
                showToast('Error deleting swarm');
            }
        }
        
        // Delete event
        async function deleteEvent(eventId) {
            if (!confirm('Are you sure you want to delete this event? This cannot be undone.')) {
                return;
            }
            
            try {
                await database.ref(`events/${eventId}`).remove();
                showToast('Event deleted successfully');
                loadMyEvents();
            } catch (error) {
                console.error('Error deleting event:', error);
                showToast('Error deleting event');
            }
        }
        
        // View route from dashboard
        function viewRouteFromDashboard(routeId) {
            closeDashboard();
            toggleSection('search', routeId);
        }
        
        // View swarm from dashboard
        function viewSwarmFromDashboard(swarmId) {
            closeDashboard();
            toggleSection('swarms', swarmId);
        }
        
        // View event from dashboard
        function viewEventFromDashboard(eventId) {
            closeDashboard();
            toggleSection('events', eventId);
        }
        
        // Edit functions (placeholder - to be implemented)
        function editRoute(routeId) {
            showToast('Edit functionality coming soon! For now, you can delete and recreate the route.');
            // TODO: Implement route editing
            // 1. Fetch route data from Firebase
            // 2. Open journey creation map
            // 3. Pre-fill form with existing data
            // 4. Update instead of create new
        }
        
        function editSwarm(swarmId) {
            showToast('Edit functionality coming soon! For now, you can delete and recreate the swarm.');
            // TODO: Implement swarm editing
            // 1. Fetch swarm data from Firebase
            // 2. Open swarm creation map
            // 3. Pre-fill form and markers with existing data
            // 4. Update instead of create new
        }
        
        function editEvent(eventId) {
            showToast('Edit functionality coming soon! For now, you can delete and recreate the event.');
            // TODO: Implement event editing
            // 1. Fetch event data from Firebase
            // 2. Open event creation map
            // 3. Pre-fill form and marker with existing data
            // 4. Update instead of create new
        }
        
        // Make dashboard functions globally accessible
        window.openDashboard = openDashboard;
        window.closeDashboard = closeDashboard;
        window.switchDashboardTab = switchDashboardTab;
        window.loadMyRoutes = loadMyRoutes;
        
        // === DRAFT SYSTEM ===
        
        // Save current route as draft
        async function saveDraft() {
            const user = auth.currentUser;
            if (!user) {
                showToast('Please sign in to save drafts');
                return;
            }
            
            if (routeCoordinates.length === 0) {
                showToast('Add at least one waypoint first');
                return;
            }
            
            try {
                const draftData = {
                    waypoints: routeCoordinates,
                    waypointLabels: waypointLabels,
                    createdBy: user.uid,
                    createdAt: new Date().toISOString(),
                    lastModified: new Date().toISOString()
                };
                
                // Save to Firebase under routeDrafts
                const draftRef = await database.ref('routeDrafts').push(draftData);
                
                showToast('‚úÖ Route saved as draft!');
                
                // Clear the map
                clearRoute();
            } catch (error) {
                console.error('Error saving draft:', error);
                showToast('‚ùå Error saving draft. Try again.');
            }
        }
        
        // Load user's drafts
        async function loadMyDrafts() {
            const user = auth.currentUser;
            if (!user) return;
            
            const contentDiv = document.getElementById('draftsContent');
            contentDiv.innerHTML = '<p style="text-align: center; color: #999;">Loading...</p>';
            
            try {
                // Get all drafts, then filter client-side (avoids Firebase indexing requirement)
                const snapshot = await database.ref('routeDrafts').once('value');
                const drafts = [];
                
                snapshot.forEach(child => {
                    const draft = child.val();
                    if (draft.createdBy === user.uid) {
                        drafts.push({ id: child.key, ...draft });
                    }
                });
                
                if (drafts.length === 0) {
                    contentDiv.innerHTML = '<p style="text-align: center; color: #999;">No drafts yet. Start creating a route to save it as a draft!</p>';
                    return;
                }
                
                // Sort by most recent first
                drafts.sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified));
                
                let html = '<div style="display: flex; flex-direction: column; gap: 1rem;">';
                
                drafts.forEach(draft => {
                    const waypointCount = draft.waypoints ? draft.waypoints.length : 0;
                    const lastModified = new Date(draft.lastModified).toLocaleString();
                    
                    html += `
                        <div style="background: rgba(30, 30, 30, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; padding: 1.5rem; cursor: pointer; transition: all 0.3s;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                                <div>
                                    <h3 style="color: var(--accent-light); margin-bottom: 0.5rem;">Draft Route - ${waypointCount} waypoints</h3>
                                    <p style="color: #999; font-size: 0.85rem;">Last modified: ${lastModified}</p>
                                </div>
                            </div>
                            
                            <div style="display: flex; gap: 0.75rem; margin-top: 1rem;">
                                <button onclick="resumeDraft('${draft.id}')" style="flex: 1; background: linear-gradient(135deg, var(--accent-color), var(--accent-light)); color: white; border: none; padding: 0.75rem; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                    ‚úèÔ∏è Resume Editing
                                </button>
                                <button onclick="deleteDraft('${draft.id}')" style="background: rgba(255, 70, 70, 0.2); color: #ff4646; border: none; padding: 0.75rem 1.5rem; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                    üóëÔ∏è Delete
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                contentDiv.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading drafts:', error);
                contentDiv.innerHTML = `<p style="text-align: center; color: #d9534f;">Error loading drafts: ${error.message}</p>`;
            }
        }
        
        // Resume editing a draft
        async function resumeDraft(draftId) {
            try {
                const snapshot = await database.ref(`routeDrafts/${draftId}`).once('value');
                const draft = snapshot.val();
                
                if (!draft) {
                    showToast('Draft not found');
                    return;
                }
                
                // Close dashboard
                closeDashboard();
                
                // Navigate to journey map
                toggleSection('journey-map');
                
                // Wait for map to initialize
                setTimeout(() => {
                    // Clear any existing route
                    clearRoute();
                    
                    // Restore waypoints
                    draft.waypoints.forEach((coords, index) => {
                        const numberIcon = L.divIcon({
                            className: 'numbered-marker',
                            html: `<div style="background: #0056b3; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${index + 1}</div>`,
                            iconSize: [32, 32],
                            iconAnchor: [16, 16]
                        });
                        
                        const marker = L.marker(coords, { icon: numberIcon }).addTo(journeyMap);
                        routeMarkers.push(marker);
                        routeCoordinates.push(coords);
                        
                        // Restore labels
                        const label = draft.waypointLabels && draft.waypointLabels[index] ? draft.waypointLabels[index] : '';
                        waypointLabels.push(label);
                        
                        // Show waypoint label input
                        const labelsContainer = document.getElementById('waypointLabelsContainer');
                        const labelsList = document.getElementById('waypointLabelsList');
                        if (labelsContainer && labelsList) {
                            labelsContainer.style.display = 'block';
                            
                            const labelInput = document.createElement('div');
                            labelInput.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
                            labelInput.innerHTML = `
                                <span style="color: var(--accent-light); font-weight: 600; min-width: 30px;">${index + 1}.</span>
                                <input type="text" 
                                       id="waypointLabel${index + 1}" 
                                       value="${label}"
                                       placeholder="e.g., Blue Bottle Coffee, Tattered Cover, etc."
                                       maxlength="50"
                                       required
                                       style="flex: 1; padding: 0.5rem; background: rgba(40, 40, 40, 0.8); border: 1px solid rgba(107, 155, 158, 0.3); border-radius: 8px; color: white; font-size: 0.9rem;">
                            `;
                            labelsList.appendChild(labelInput);
                            
                            // Update waypointLabels array when input changes
                            const input = document.getElementById(`waypointLabel${index + 1}`);
                            input.addEventListener('input', (e) => {
                                waypointLabels[index] = e.target.value;
                                if (e.target.value.trim() === '') {
                                    e.target.style.borderColor = 'rgba(220, 38, 38, 0.6)';
                                } else {
                                    e.target.style.borderColor = 'rgba(107, 155, 158, 0.3)';
                                }
                            });
                        }
                    });
                    
                    // Draw route if multiple waypoints
                    if (routeCoordinates.length > 1) {
                        routePath = L.polyline(routeCoordinates, { color: 'var(--accent-color)', weight: 4 }).addTo(journeyMap);
                    }
                    
                    // Center map on route
                    if (routeCoordinates.length > 0) {
                        const bounds = L.latLngBounds(routeCoordinates);
                        journeyMap.fitBounds(bounds, { padding: [50, 50] });
                    }
                    
                    showToast('‚úÖ Draft loaded! Continue editing.');
                    
                    // Delete the draft now that it's loaded
                    database.ref(`routeDrafts/${draftId}`).remove();
                }, 500);
                
            } catch (error) {
                console.error('Error resuming draft:', error);
                showToast('‚ùå Error loading draft');
            }
        }
        
        // Delete a draft
        async function deleteDraft(draftId) {
            if (!confirm('Delete this draft? This cannot be undone.')) {
                return;
            }
            
            try {
                await database.ref(`routeDrafts/${draftId}`).remove();
                showToast('‚úÖ Draft deleted');
                loadMyDrafts(); // Reload the list
            } catch (error) {
                console.error('Error deleting draft:', error);
                showToast('‚ùå Error deleting draft');
            }
        }
        
        // Make draft functions globally accessible
        window.saveDraft = saveDraft;
        window.loadMyDrafts = loadMyDrafts;
        window.resumeDraft = resumeDraft;
        window.deleteDraft = deleteDraft;
        window.loadMySwarms = loadMySwarms;
        window.loadMyEvents = loadMyEvents;
        window.loadMyLikes = loadMyLikes;
        window.deleteRoute = deleteRoute;
        
        // === EDIT FUNCTIONS ===
        
        // Edit existing route
        async function editRoute(routeId) {
            try {
                const snapshot = await database.ref(`routes/${routeId}`).once('value');
                const route = snapshot.val();
                
                if (!route) {
                    showToast('Route not found');
                    return;
                }
                
                // Store the route ID and data for updating later
                window.editingRouteId = routeId;
                window.editingRouteData = {
                    name: route.name,
                    description: route.description,
                    category: route.category
                };
                
                // Close dashboard
                closeDashboard();
                
                // Navigate to journey map
                toggleSection('journey-map');
                
                // Wait for map to initialize
                setTimeout(() => {
                    // Clear any existing route
                    clearRoute();
                    
                    // Restore waypoints
                    route.waypoints.forEach((coords, index) => {
                        const numberIcon = L.divIcon({
                            className: 'numbered-marker',
                            html: `<div style="background: #0056b3; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${index + 1}</div>`,
                            iconSize: [32, 32],
                            iconAnchor: [16, 16]
                        });
                        
                        const marker = L.marker(coords, { icon: numberIcon }).addTo(journeyMap);
                        routeMarkers.push(marker);
                        routeCoordinates.push(coords);
                        
                        // Restore labels
                        const label = route.waypointLabels && route.waypointLabels[index] ? route.waypointLabels[index] : '';
                        waypointLabels.push(label);
                        
                        // Show waypoint label input
                        const labelsContainer = document.getElementById('waypointLabelsContainer');
                        const labelsList = document.getElementById('waypointLabelsList');
                        if (labelsContainer && labelsList) {
                            labelsContainer.style.display = 'block';
                            
                            const labelInput = document.createElement('div');
                            labelInput.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
                            labelInput.innerHTML = `
                                <span style="color: var(--accent-light); font-weight: 600; min-width: 30px;">${index + 1}.</span>
                                <input type="text" 
                                       id="waypointLabel${index + 1}" 
                                       value="${label}"
                                       placeholder="e.g., Blue Bottle Coffee, Tattered Cover, etc."
                                       maxlength="50"
                                       required
                                       style="flex: 1; padding: 0.5rem; background: rgba(40, 40, 40, 0.8); border: 1px solid rgba(107, 155, 158, 0.3); border-radius: 8px; color: white; font-size: 0.9rem;">
                            `;
                            labelsList.appendChild(labelInput);
                            
                            // Update waypointLabels array when input changes
                            const input = document.getElementById(`waypointLabel${index + 1}`);
                            input.addEventListener('input', (e) => {
                                waypointLabels[index] = e.target.value;
                                if (e.target.value.trim() === '') {
                                    e.target.style.borderColor = 'rgba(220, 38, 38, 0.6)';
                                } else {
                                    e.target.style.borderColor = 'rgba(107, 155, 158, 0.3)';
                                }
                            });
                        }
                    });
                    
                    // Draw route if multiple waypoints
                    if (routeCoordinates.length > 1) {
                        routePath = L.polyline(routeCoordinates, { color: 'var(--accent-color)', weight: 4 }).addTo(journeyMap);
                    }
                    
                    // Center map on route
                    if (routeCoordinates.length > 0) {
                        const bounds = L.latLngBounds(routeCoordinates);
                        journeyMap.fitBounds(bounds, { padding: [50, 50] });
                    }
                    
                    showToast('‚úèÔ∏è Editing route. Make changes and click Save Route.');
                }, 500);
                
            } catch (error) {
                console.error('Error loading route for editing:', error);
                showToast('‚ùå Error loading route');
            }
        }
        
        // Edit existing swarm
        async function editSwarm(swarmId) {
            try {
                const snapshot = await database.ref(`swarms/${swarmId}`).once('value');
                const swarm = snapshot.val();
                
                if (!swarm) {
                    showToast('Swarm not found');
                    return;
                }
                
                // Check if date has passed
                const swarmDate = new Date(swarm.date);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                if (swarmDate < today) {
                    showToast('Cannot edit swarm - date has passed');
                    return;
                }
                
                // Store the swarm ID for updating later
                window.editingSwarmId = swarmId;
                
                // Open the swarm modal
                openCreateSwarmModal();
                
                // Populate modal with existing data
                setTimeout(() => {
                    document.querySelector('input[name="swarmTitle"]').value = swarm.title;
                    document.querySelector('textarea[name="swarmDescription"]').value = swarm.description || '';
                    document.querySelector('input[name="swarmDate"]').value = swarm.date;
                    document.querySelector('input[name="swarmTime"]').value = swarm.time;
                    document.querySelector('input[name="swarmDuration"]').value = swarm.duration || '';
                    
                    // Update modal title
                    document.querySelector('#createSwarmModal h2').textContent = 'Edit Shopping Swarm';
                }, 100);
                
            } catch (error) {
                console.error('Error loading swarm for editing:', error);
                showToast('‚ùå Error loading swarm');
            }
        }
        
        // Edit existing event
        async function editEvent(eventId) {
            try {
                const snapshot = await database.ref(`events/${eventId}`).once('value');
                const event = snapshot.val();
                
                if (!event) {
                    showToast('Event not found');
                    return;
                }
                
                // Check if date has passed
                const eventDate = new Date(event.startDate);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                if (eventDate < today) {
                    showToast('Cannot edit event - date has passed');
                    return;
                }
                
                // Store the event ID for updating later
                window.editingEventId = eventId;
                
                // Open the event modal
                openCreateEventModal();
                
                // Populate modal with existing data
                setTimeout(() => {
                    document.querySelector('input[name="eventName"]').value = event.name;
                    document.querySelector('textarea[name="eventDescription"]').value = event.description || '';
                    document.querySelector('input[name="eventLocation"]').value = event.location;
                    document.querySelector('input[name="eventStartDate"]').value = event.startDate;
                    document.querySelector('input[name="eventStartTime"]').value = event.startTime;
                    if (event.endDate) document.querySelector('input[name="eventEndDate"]').value = event.endDate;
                    if (event.endTime) document.querySelector('input[name="eventEndTime"]').value = event.endTime;
                    
                    // Update modal title
                    document.querySelector('#createEventModal h2').textContent = 'Edit Event';
                }, 100);
                
            } catch (error) {
                console.error('Error loading event for editing:', error);
                showToast('‚ùå Error loading event');
            }
        }
        
        window.editRoute = editRoute;
        window.deleteSwarm = deleteSwarm;
        window.deleteEvent = deleteEvent;
        window.editRoute = editRoute;
        window.editSwarm = editSwarm;
        window.editEvent = editEvent;
        window.viewRouteFromDashboard = viewRouteFromDashboard;
        window.viewSwarmFromDashboard = viewSwarmFromDashboard;
        window.viewEventFromDashboard = viewEventFromDashboard;
        
        // ===== DATABASE HELPER FUNCTIONS =====
        // These wrap Firebase calls so we can easily switch databases later
        
        // Geocode address to get lat/lng coordinates
        async function geocodeAddress(address) {
            try {
                const accessToken = 'pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3cifQ.EPETOMFI41QInYccb4Cehg';
                
                // No proximity bias - users must be specific with city/state
                // Examples: "Baker Neighborhood, Denver" or "Little Italy, Manhattan, NY"
                const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(address)}.json?access_token=${accessToken}&limit=1`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    const [lng, lat] = data.features[0].center;
                    return { lat, lng, fullAddress: data.features[0].place_name };
                }
                return null;
            } catch (error) {
                console.error('Geocoding error:', error);
                return null;
            }
        }
        
        // ===== DATABASE HELPER FUNCTIONS =====
        
        // Save event to Firebase
        async function saveEventToFirebase(eventData) {
            try {
                const newEventRef = database.ref('events').push();
                await newEventRef.set({
                    ...eventData,
                    id: newEventRef.key,
                    created: new Date().toISOString()
                });
                return newEventRef.key;
            } catch (error) {
                console.error('Error saving event:', error);
                showToast('Error saving event. Please try again.');
            }
        }
        
        // Save swarm to Firebase
        async function saveSwarmToFirebase(swarmData) {
            try {
                const newSwarmRef = database.ref('swarms').push();
                await newSwarmRef.set({
                    ...swarmData,
                    id: newSwarmRef.key,
                    created: new Date().toISOString()
                });
                return newSwarmRef.key;
            } catch (error) {
                console.error('Error saving swarm:', error);
                showToast('Error saving swarm. Please try again.');
            }
        }
        
        // Get all events from Firebase
        async function getAllEvents() {
            try {
                const snapshot = await database.ref('events').once('value');
                const events = [];
                snapshot.forEach((childSnapshot) => {
                    events.push({
                        id: childSnapshot.key,
                        ...childSnapshot.val()
                    });
                });
                return events;
            } catch (error) {
                console.error('Error loading events:', error);
                return [];
            }
        }
        
        // Get all swarms from Firebase
        async function getAllSwarms() {
            try {
                const snapshot = await database.ref('swarms').once('value');
                const swarms = [];
                snapshot.forEach((childSnapshot) => {
                    swarms.push({
                        id: childSnapshot.key,
                        ...childSnapshot.val()
                    });
                });
                return swarms;
            } catch (error) {
                console.error('Error loading swarms:', error);
                return [];
            }
        }
        
        // Update interest count in Firebase
        async function updateInterestCount(type, id, newCount) {
            try {
                const path = type === 'swarm' ? `swarms/${id}` : `events/${id}`;
                await database.ref(path).update({
                    interested: newCount
                });
            } catch (error) {
                console.error('Error updating interest:', error);
            }
        }
        
        // Listen for real-time updates (optional - shows changes instantly)
        function listenForEventUpdates(callback) {
            database.ref('events').on('value', (snapshot) => {
                const events = [];
                snapshot.forEach((childSnapshot) => {
                    events.push({
                        id: childSnapshot.key,
                        ...childSnapshot.val()
                    });
                });
                callback(events);
            });
        }
        
        function listenForSwarmUpdates(callback) {
            database.ref('swarms').on('value', (snapshot) => {
                const swarms = [];
                snapshot.forEach((childSnapshot) => {
                    swarms.push({
                        id: childSnapshot.key,
                        ...childSnapshot.val()
                    });
                });
                callback(swarms);
            });
        }
        
        // Get all routes from Firebase
        function getAllRoutes() {
            return new Promise((resolve) => {
                database.ref('routes').once('value', (snapshot) => {
                    const routes = [];
                    snapshot.forEach((childSnapshot) => {
                        const route = childSnapshot.val();
                        // Exclude soft-deleted routes from public view
                        if (!route.deleted) {
                            routes.push({
                                id: childSnapshot.key,
                                ...route
                            });
                        }
                    });
                    resolve(routes);
                });
            });
        }
        
        function listenForRouteUpdates(callback) {
            database.ref('routes').on('value', (snapshot) => {
                const routes = [];
                snapshot.forEach((childSnapshot) => {
                    const route = childSnapshot.val();
                    // Exclude soft-deleted routes from public view
                    if (!route.deleted) {
                        routes.push({
                            id: childSnapshot.key,
                            ...route
                        });
                    }
                });
                callback(routes);
            });
        }
    </script>
    
    <script>
        // Map variables
        let journeyMap = null;
        let searchMap = null;
        let swarmMap = null;
        let eventMap = null;
        let routeMarkers = [];
        let routePath = null;
        let routeCoordinates = [];
        let waypointLabels = []; // Store custom labels for each waypoint
        let allRoutesData = []; // Store all routes for search map
        let selectedRoute = null; // Currently selected route
        
        // Toggle Sections - Opens fullscreen modal with maps
        function toggleSection(sectionId, highlightId = null) {
            // Check auth for creation sections (not browsing)
            const creationSections = ['journey-map', 'swarm-map', 'event-map', 'swarm-map-v2', 'event-map-v2'];
            if (creationSections.includes(sectionId)) {
                if (!checkAuthAndVerification()) {
                    return; // Stop if not authorized
                }
            }
            
            // Lock background scrolling - use the choreography-active class
            document.body.classList.add('choreography-active');
            
            // Create fullscreen modal
            const modal = document.createElement('div');
            modal.className = 'modal-fullscreen show';
            modal.id = 'fullscreen-' + sectionId;
            modal.style.cssText = 'display: block; position: fixed; z-index: 2000; left: 0; top: 0; right: 0; bottom: 0; width: 100%; background-color: rgba(10, 10, 10, 0.98);';
            
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '&times;';
            closeBtn.style.cssText = 'position: fixed; top: 2rem; right: 2rem; width: 50px; height: 50px; background: rgba(107, 155, 158, 0.9); border: none; border-radius: 50%; color: white; font-size: 2rem; cursor: pointer; z-index: 2001;';
            closeBtn.onclick = () => {
                modal.remove();
                // Unlock background scrolling
                document.body.classList.remove('choreography-active');
                // Reset map variables so they can be recreated
                journeyMap = null;
                searchMap = null;
                swarmMap = null;
                eventMap = null;
                // Scroll back to Explore section
                setTimeout(() => {
                    const exploreSection = document.querySelector('.features-section');
                    if (exploreSection) {
                        exploreSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);
            };
            
            const content = document.createElement('div');
            content.style.cssText = 'padding: 2rem; max-width: 1600px; margin: 0 auto; padding-bottom: 3rem; position: absolute; top: 0; bottom: 0; left: 0; right: 0; overflow: hidden;';
            
            // Create content based on section
            const mapMode = sectionId.includes('swarm') ? 'swarm' : sectionId.includes('event') ? 'event' : 'journey';
            
            if (sectionId === 'journey-map' || sectionId === 'swarm-map-v2' || sectionId === 'event-map-v2') {
                // Universal map section - changes based on mode
                content.style.cssText = 'padding: 0; max-width: none; margin: 0; position: absolute; top: 0; bottom: 0; left: 0; right: 0; overflow: hidden; display: flex; flex-direction: column;';
                
                const titles = {
                    journey: 'Share Your Journey',
                    swarm: 'üõçÔ∏è Create Shopping Swarm',
                    event: 'üéâ Promote Your Event'
                };
                
                const hints = {
                    journey: 'üí° Search for a location, then click the map to add waypoints',
                    swarm: 'üí° Search for a location, then click the map to pin your meeting point',
                    event: 'üí° Search for a location, then click the map to pin your event location'
                };
                
                const buttons = {
                    journey: `
                        <button class="feature-btn" onclick="openSaveRouteModal()">Save Route</button>
                        <button class="feature-btn" onclick="saveDraft()" style="background: rgba(107, 155, 158, 0.3);">Save as Draft</button>
                        <button class="feature-btn" onclick="clearRoute()">Clear Route</button>
                    `,
                    swarm: `
                        <button id="saveSwarmMapBtn" class="feature-btn" onclick="openCreateSwarmModal()" disabled>Save Swarm</button>
                        <button class="feature-btn" onclick="clearSwarm()">Clear Swarm</button>
                        <button class="feature-btn" onclick="showToast('Share link copied!')">Share Swarm</button>
                    `,
                    event: `
                        <button id="saveEventMapBtn" class="feature-btn" onclick="openCreateEventModal()" disabled>Save Event</button>
                        <button class="feature-btn" onclick="clearEvent()">Clear Event</button>
                        <button class="feature-btn" onclick="showToast('Share link copied!')">Share Event</button>
                    `
                };
                
                content.innerHTML = `
                    <div style="padding: 2rem; text-align: center; background: rgba(20, 20, 20, 0.98); position: relative;">
                        <h2 style="color: var(--accent-color); margin: 0 0 1rem 0;">${titles[mapMode]}</h2>
                        <div style="max-width: 600px; margin: 0 auto;">
                            <input type="text" id="mapSearch" placeholder="Search address to zoom to location..." style="width: 100%; padding: 1rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-size: 1rem; font-family: 'Poppins', sans-serif;">
                            <div id="mapSearchSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: rgba(30, 30, 30, 0.98); border: 2px solid rgba(107, 155, 158, 0.3); border-top: none; border-radius: 0 0 15px 15px; max-height: 300px; overflow-y: auto; z-index: 1000; display: none;"></div>
                            
                            <!-- GPS Button (Mobile Only) -->
                            <button id="gpsLocationBtn" onclick="handleGPSClick('${mapMode}')" style="display: none; margin-top: 0.75rem; width: 100%; padding: 0.75rem; background: linear-gradient(135deg, var(--accent-color), var(--accent-light)); color: white; border: none; border-radius: 15px; font-weight: 600; cursor: pointer; font-size: 0.95rem; transition: all 0.3s ease;">
                                üìç Use My Current Location
                            </button>
                            
                            <p style="color: #999; font-size: 0.85rem; margin-top: 0.5rem;">${hints[mapMode]}</p>
                        </div>
                        <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: center;">
                            ${buttons[mapMode]}
                        </div>
                    </div>
                    <div id="map" style="height: calc(100vh - 400px); width: 100%;"></div>
                    
                    <!-- Multi-business link (only shows for swarm mode) -->
                    <div id="multiBusinessContainer" style="display: none; padding: 1rem 2rem; background: rgba(25, 25, 25, 0.95); border-top: 1px solid rgba(107, 155, 158, 0.2); text-align: center;">
                        <p style="color: #d4d4d4; margin: 0; font-size: 0.9rem;">
                            Planning to visit multiple businesses? 
                            <a href="#" id="addBusinessLink" onclick="event.preventDefault(); addAnotherBusiness();" style="color: var(--accent-color); font-weight: 600; text-decoration: underline; margin-left: 0.5rem;">Add another location</a>
                        </p>
                        <p id="businessCount" style="color: var(--accent-light); margin: 0.5rem 0 0 0; font-size: 0.85rem; font-weight: 600;"></p>
                    </div>
                    
                    <!-- Swarm Business Labels (only shows for swarm mode) -->
                    <div id="swarmBusinessLabelsContainer" style="display: none; padding: 1rem 2rem; background: rgba(25, 25, 25, 0.95); max-height: 200px; overflow-y: auto; border-top: 1px solid rgba(107, 155, 158, 0.2);">
                        <h4 style="color: var(--accent-color); margin-bottom: 0.75rem; font-size: 0.95rem;">üè™ Label Your Businesses (Required)</h4>
                        <div id="swarmBusinessLabelsList" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
                    </div>
                    
                    <!-- Waypoint Labels (only shows for journey mode) -->
                    <div id="waypointLabelsContainer" style="display: none; padding: 1rem 2rem; background: rgba(25, 25, 25, 0.95); max-height: 200px; overflow-y: auto;">
                        <h4 style="color: var(--accent-color); margin-bottom: 0.75rem; font-size: 0.95rem;">üìç Label Your Stops (Required)</h4>
                        <div id="waypointLabelsList" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
                    </div>
                    
                    <!-- Info Panel -->
                    <div id="journeyInfoPanel" style="display: none; padding: 1.5rem 2rem; background: rgba(25, 25, 25, 0.95); border-top: 2px solid rgba(107, 155, 158, 0.3); max-height: 200px; overflow-y: auto;">
                        <div id="journeyInfoContent"></div>
                    </div>
                `;
             } else if (sectionId === 'search') {
                content.innerHTML = `
                    <h2 style="color: var(--accent-color); margin-bottom: 0.5rem;">Search Routes</h2>
                    <p style="color: #d4d4d4; margin-bottom: 1rem;">Discover community-shared walking routes and find your next adventure</p>
                    
                    <div style="margin-bottom: 1rem;">
                        <label for="categoryFilter" style="color: var(--accent-color); font-weight: 600; display: block; margin-bottom: 0.5rem;">Filter by Category:</label>
                        <select id="categoryFilter" style="width: 100%; padding: 0.75rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif; font-size: 1rem; cursor: pointer; max-height: 150px; overflow-y: auto;">
                            <option value="all">All Categories</option>
                            <option value="Coffee Shops">‚òï Coffee Shops</option>
                            <option value="Tacos">üåÆ Tacos</option>
                            <option value="Pizza">üçï Pizza</option>
                            <option value="Burgers">üçî Burgers</option>
                            <option value="Asian Cuisine">üçú Asian Cuisine</option>
                            <option value="Italian">üçù Italian</option>
                            <option value="Bakeries & Cafes">ü•ê Bakeries & Cafes</option>
                            <option value="Bars & Breweries">üç∫ Bars & Breweries</option>
                            <option value="Cocktail Bars">üç∏ Cocktail Bars</option>
                            <option value="Wine Bars">üç∑ Wine Bars</option>
                            <option value="Live Music Venues">üéµ Live Music Venues</option>
                            <option value="Nightlife">üåÉ Nightlife</option>
                            <option value="Shopping Districts">üõçÔ∏è Shopping Districts</option>
                            <option value="Fashion & Boutiques">üëï Fashion & Boutiques</option>
                            <option value="Bookstores">üìö Bookstores</option>
                            <option value="Art Galleries">üé® Art Galleries</option>
                            <option value="Theater & Performance">üé≠ Theater & Performance</option>
                            <option value="Museums">üèõÔ∏è Museums</option>
                            <option value="Historic Sites">üè∫ Historic Sites</option>
                            <option value="Architecture">‚õ™ Architecture</option>
                            <option value="Parks & Gardens">üå≥ Parks & Gardens</option>
                            <option value="Scenic Walks">üèûÔ∏è Scenic Walks</option>
                            <option value="Hiking Trails">üö∂ Hiking Trails</option>
                            <option value="Bike Routes">üö¥ Bike Routes</option>
                            <option value="Waterfront">üèñÔ∏è Waterfront</option>
                            <option value="Seasonal">üå∏ Seasonal (Cherry Blossoms, Fall Colors, etc.)</option>
                            <option value="Photo Spots">üì∏ Photo Spots</option>
                            <option value="Spooky & Ghost Tours">üéÉ Spooky & Ghost Tours</option>
                            <option value="Holiday Themed">üéÑ Holiday Themed</option>
                            <option value="Neighborhood Tours">üè† Neighborhood Tours</option>
                            <option value="Hidden Gems">üíé Hidden Gems</option>
                            <option value="Street Art">üé™ Street Art</option>
                            <option value="Markets & Bazaars">üõí Markets & Bazaars</option>
                            <option value="Cultural Districts">üåç Cultural Districts</option>
                            <option value="Religious Sites">üïå Religious Sites</option>
                            <option value="Castles & Landmarks">üè∞ Castles & Landmarks</option>
                            <option value="Entertainment Districts">üé° Entertainment Districts</option>
                            <option value="Fitness & Sports">üèãÔ∏è Fitness & Sports</option>
                            <option value="Wellness & Yoga">üßò Wellness & Yoga</option>
                            <option value="Family Friendly">üë∂ Family Friendly</option>
                            <option value="Dog Friendly">üêï Dog Friendly</option>
                            <option value="Accessible Routes">‚ôø Accessible Routes</option>
                            <option value="Educational Tours">üéì Educational Tours</option>
                            <option value="Business Districts">üè¢ Business Districts</option>
                            <option value="Bridge Walks">üåâ Bridge Walks</option>
                            <option value="User Added">‚ú® User Added</option>
                        </select>
                    </div>
                    
                    <!-- Secondary dropdown for custom categories -->
                    <div id="customCategoryFilterContainer" style="margin-bottom: 1rem; display: none;">
                        <label for="customCategoryFilter" style="color: var(--accent-color); font-weight: 600; display: block; margin-bottom: 0.5rem;">‚ú® User Created Categories:</label>
                        <select id="customCategoryFilter" style="width: 100%; padding: 0.75rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif; font-size: 1rem; cursor: pointer;">
                            <option value="">All Custom Categories</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 1rem;">
                        <h3 style="color: var(--accent-light); margin-bottom: 0.5rem;">üîç Search Near Me</h3>
                        <div style="margin-bottom: 0.5rem; position: relative;">
                            <input type="text" id="mapSearch" placeholder="üëâ Enter your zip code to find routes near you..." style="width: 100%; padding: 1rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif; font-size: 1rem; animation: searchPulse 2s ease-in-out 3;">
                            <div id="mapSearchSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: rgba(30, 30, 30, 0.98); border: 2px solid rgba(107, 155, 158, 0.3); border-top: none; border-radius: 0 0 15px 15px; max-height: 300px; overflow-y: auto; z-index: 1000; display: none;"></div>
                        </div>
                        <button class="feature-btn" onclick="showToast('Searching routes...')">Search</button>
                    </div>
                    
                    <div id="search-map" style="height: 450px; border-radius: 15px; margin: 0.5rem 0; background: #1a1a1a;"></div>
                    
                    <!-- Info Panel -->
                    <div id="searchInfoPanel" style="display: none; padding: 1.5rem; background: rgba(25, 25, 25, 0.95); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; margin: 1rem auto 0 auto; max-width: 500px;">
                        <div id="searchInfoContent"></div>
                    </div>
                    
                    <p style="color: #999; font-size: 0.9rem; margin-top: 1rem; text-align: center;">üí° Click any route on the map to view details below</p>
                `;
            } else if (sectionId === 'swarms') {
                content.innerHTML = `
                    <h2 style="color: var(--accent-color); margin-bottom: 1rem;">Shopping Swarms</h2>
                    <p style="color: #d4d4d4; margin-bottom: 1.5rem;">Organize or join community walks where locals explore, shop, and support businesses together ‚Äî a spontaneous celebration of local culture!</p>
                    
                    <div style="margin-top: 2rem; margin-bottom: 1.5rem;">
                        <h3 style="color: var(--accent-light); margin-bottom: 1rem;">üîç Search Near Me</h3>
                        <div style="margin-bottom: 1rem; position: relative;">
                            <input type="text" id="swarmLocationSearch" placeholder="üëâ Enter your zip code to find swarms near you..." style="width: 100%; padding: 1rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif; font-size: 1rem; animation: searchPulse 2s ease-in-out 3;">
                            <div id="swarmSearchSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: rgba(30, 30, 30, 0.98); border: 2px solid rgba(107, 155, 158, 0.3); border-top: none; border-radius: 0 0 15px 15px; max-height: 300px; overflow-y: auto; z-index: 1000; display: none;"></div>
                        </div>
                        <button class="feature-btn" onclick="showToast('Searching swarms...')">Search</button>
                    </div>
                    
                    <div id="swarm-map" style="height: 450px; border-radius: 15px; margin: 0.5rem 0; background: #1a1a1a;"></div>
                    
                    <!-- Info Panel -->
                    <div id="swarmInfoPanel" style="display: none; padding: 1.5rem; background: rgba(25, 25, 25, 0.95); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; margin: 1rem auto 0 auto; max-width: 500px;">
                        <div id="swarmInfoContent"></div>
                    </div>
                    
                    <p style="color: #999; font-size: 0.9rem; margin-top: 1rem; text-align: center;">üí° Click any swarm pin to view details below</p>
                `;
            } else if (sectionId === 'events') {
                content.innerHTML = `
                    <h2 style="color: var(--accent-color); margin-bottom: 1rem;">Local Events</h2>
                    <p style="color: #d4d4d4; margin-bottom: 1.5rem;">Discover and promote neighborhood celebrations, block parties, sidewalk sales, and community festivals.</p>
                    
                    <div style="margin-top: 2rem; margin-bottom: 1.5rem;">
                        <h3 style="color: var(--accent-light); margin-bottom: 1rem;">üîç Find Events Near You</h3>
                        <div style="margin-bottom: 1rem; position: relative;">
                            <input type="text" id="eventLocationSearch" placeholder="üëâ Enter your zip code to find events near you..." style="width: 100%; padding: 1rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif; font-size: 1rem; animation: searchPulse 2s ease-in-out 3;">
                            <div id="eventSearchSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: rgba(30, 30, 30, 0.98); border: 2px solid rgba(107, 155, 158, 0.3); border-top: none; border-radius: 0 0 15px 15px; max-height: 300px; overflow-y: auto; z-index: 1000; display: none;"></div>
                        </div>
                        <button class="feature-btn" onclick="showToast('Searching events...')">Search Events</button>
                    </div>
                    
                    <div id="event-map" style="height: 450px; border-radius: 15px; margin: 0.5rem 0; background: #1a1a1a;"></div>
                    
                    <!-- Info Panel -->
                    <div id="eventInfoPanel" style="display: none; padding: 1.5rem; background: rgba(25, 25, 25, 0.95); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; margin: 1rem auto 0 auto; max-width: 500px;">
                        <div id="eventInfoContent"></div>
                    </div>
                    
                    <p style="color: #999; font-size: 0.9rem; margin-top: 1rem; text-align: center;">üí° Click any event pin to view details below</p>
                `;
            }
            
            modal.appendChild(closeBtn);
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Initialize maps after DOM is ready
            setTimeout(() => {
                if (sectionId === 'journey-map' || sectionId === 'swarm-map-v2' || sectionId === 'event-map-v2') {
                    const mapElement = document.getElementById('map');
                    if (mapElement && !journeyMap) {
                        journeyMap = L.map(mapElement).setView([39.7392, -104.9903], 13);
                        L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3gifQ.EPETOMFI41QInYccb4Cehg', {
                             tileSize: 512,
                            zoomOffset: -1
                        }).addTo(journeyMap);
                        L.control.attribution({ position: 'bottomright', prefix: false }).addAttribution('¬© <a href="https://www.mapbox.com/">Mapbox</a>').addTo(journeyMap);
                        
                        // Set up click handler based on mode
                        if (mapMode === 'journey') {
                            journeyMap.on('click', function(e) {
                                addWaypoint(e.latlng);
                            });
                        } else if (mapMode === 'swarm') {
                            // Always reset swarm markers array when opening creation map
                            window.swarmMarkers = [];
                            window.swarmLocations = [];
                            window.swarmBusinessLabels = [];
                            
                            // Reset multi-business mode flag
                            window.swarmMultiBusinessMode = false;
                            
                            // Show multi-business container
                            const multiBusinessContainer = document.getElementById('multiBusinessContainer');
                            if (multiBusinessContainer) {
                                multiBusinessContainer.style.display = 'block';
                            }
                            
                            journeyMap.on('click', function(e) {
                                addSwarmMarker(e.latlng);
                            });
                        } else if (mapMode === 'event') {
                            journeyMap.on('click', function(e) {
                                if (window.eventMarker) {
                                    journeyMap.removeLayer(window.eventMarker);
                                }
                                
                                // Create custom pin icon to match swarm/journey style
                                const eventPinIcon = L.divIcon({
                                    className: 'event-marker-pin',
                                    html: '<div style="background: #0056b3; color: white; border-radius: 50% 50% 50% 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; transform: rotate(-45deg); box-shadow: 0 2px 8px rgba(0,0,0,0.3);"><span style="transform: rotate(45deg);">üìç</span></div>',
                                    iconSize: [32, 32],
                                    iconAnchor: [16, 32]
                                });
                                
                                window.eventMarker = L.marker([e.latlng.lat, e.latlng.lng], { icon: eventPinIcon }).addTo(journeyMap);
                                
                                // Store location with reverse geocoding for address
                                reverseGeocode(e.latlng.lat, e.latlng.lng).then(address => {
                                    window.eventLocation = { 
                                        lat: e.latlng.lat, 
                                        lng: e.latlng.lng,
                                        address: address
                                    };
                                });
                                
                                // Enable the Save Event button
                                const saveBtn = document.getElementById('saveEventMapBtn');
                                if (saveBtn) saveBtn.disabled = false;
                                showToast('Location pinned! Click "Save Event" to continue.');
                            });
                        }
                        
                        // Add search autocomplete functionality
                        const searchInput = document.getElementById('mapSearch');
                        const suggestionsDiv = document.getElementById('mapSearchSuggestions');
                        let searchTimeout;
                        
                        if (searchInput && suggestionsDiv) {
                            searchInput.addEventListener('input', function(e) {
                                const query = e.target.value.trim();
                                clearTimeout(searchTimeout);
                                
                                if (query.length < 2) {
                                    suggestionsDiv.style.display = 'none';
                                    return;
                                }
                                
                                searchTimeout = setTimeout(() => {
                                    fetchLocationSuggestions(query, suggestionsDiv, journeyMap, searchInput);
                                }, 100);
                            });
                            
                            searchInput.addEventListener('keypress', function(e) {
                                if (e.key === 'Enter' && suggestionsDiv.style.display === 'none') {
                                    searchLocation(searchInput.value, journeyMap);
                                }
                            });
                            
                            document.addEventListener('click', function(e) {
                                if (!searchInput.contains(e.target) && !suggestionsDiv.contains(e.target)) {
                                    suggestionsDiv.style.display = 'none';
                                }
                            });
                        }
                        
                        // Show GPS button only on mobile devices
                        const gpsBtn = document.getElementById('gpsLocationBtn');
                        if (gpsBtn && isMobileDevice()) {
                            gpsBtn.style.display = 'block';
                        }
                    }
             
                } else if (sectionId === 'search') {
                    const mapElement = document.getElementById('search-map');
                    // Clean up existing map if it exists
                    if (searchMap) {
                        searchMap.remove();
                        searchMap = null;
                    }
                    if (mapElement) {
                        // Remove Leaflet's internal container reference if it exists
                        if (mapElement._leaflet_id) {
                            delete mapElement._leaflet_id;
                        }
                        searchMap = L.map(mapElement).setView([39.7392, -104.9903], 13);
                        L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3gifQ.EPETOMFI41QInYccb4Cehg', {
                            tileSize: 512,
                            zoomOffset: -1
                        }).addTo(searchMap);
                        
                        // Add clean Mapbox attribution
                        L.control.attribution({ position: "bottomright", prefix: false }).addAttribution("¬© <a href=\"https://www.mapbox.com/\">Mapbox</a>").addTo(searchMap);
                        // Load routes from Firebase
                        allRoutesData = []; // Reset
                        selectedRoute = null; // Reset
                        
                        getAllRoutes().then(routes => {
                            allRoutesData = []; // Reset global array
                            
                            routes.forEach((route, index) => {
                                if (route.waypoints && route.waypoints.length >= 2) {
                                    // Use street-following geometry if available, otherwise use waypoints
                                    let routePath;
                                    if (route.streetGeometry && route.streetGeometry.length > 0) {
                                        // Convert Mapbox coordinates [lng, lat] to Leaflet format [lat, lng]
                                        routePath = route.streetGeometry.map(coord => [coord[1], coord[0]]);
                                    } else {
                                        // Fall back to straight lines between waypoints
                                        routePath = route.waypoints;
                                    }
                                    
                                    // Create polyline (don't add to map yet)
                                    const polyline = L.polyline(routePath, { 
                                        color: "#8DBCC0", 
                                        weight: 4, 
                                        opacity: 0.7 
                                    });
                                    
                                    // Create plain pin for initial display (first waypoint only) (don't add to map yet)
                                    const plainPinIcon = L.divIcon({
                                        className: 'route-pin',
                                        html: '<div style="background: #0056b3; color: white; border-radius: 50% 50% 50% 0; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; transform: rotate(-45deg); box-shadow: 0 2px 8px rgba(0,0,0,0.3);"><span style="transform: rotate(45deg);">üìç</span></div>',
                                        iconSize: [28, 28],
                                        iconAnchor: [14, 28]
                                    });
                                    const plainPin = L.marker(route.waypoints[0], { icon: plainPinIcon });
                                    
                                    // Create numbered waypoint markers (don't add to map initially)
                                    const markers = [];
                                    route.waypoints.forEach((waypoint, wpIndex) => {
                                        const numberIcon = L.divIcon({
                                            className: 'waypoint-number',
                                            html: '<div style="background: #0056b3; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">' + (wpIndex + 1) + '</div>',
                                            iconSize: [32, 32],
                                            iconAnchor: [16, 16]
                                        });
                                        const marker = L.marker(waypoint, { icon: numberIcon });
                                        markers.push(marker);
                                    });
                                    
                                    // Store route data
                                    allRoutesData.push({
                                        route: route,
                                        polyline: polyline,
                                        markers: markers,
                                        plainPin: plainPin
                                    });
                                    
                                    // Click handler for highlighting and showing info
                                    polyline.on('click', async function() {
                                        // Hide all plain pins and numbered markers from all routes, fade polylines
                                        allRoutesData.forEach(r => {
                                            r.polyline.setStyle({ opacity: 0.3, weight: 3 });
                                            // Hide plain pin
                                            if (r.plainPin && searchMap.hasLayer(r.plainPin)) {
                                                searchMap.removeLayer(r.plainPin);
                                            }
                                            // Hide numbered markers
                                            r.markers.forEach(m => {
                                                if (searchMap.hasLayer(m)) {
                                                    searchMap.removeLayer(m);
                                                }
                                            });
                                        });
                                        
                                        // Highlight selected route and show ALL its numbered waypoints
                                        polyline.setStyle({ opacity: 1, weight: 6, color: '#0056b3' });
                                        markers.forEach(m => {
                                            if (!searchMap.hasLayer(m)) {
                                                m.addTo(searchMap);
                                            }
                                            m.setOpacity(1);
                                        });
                                        selectedRoute = route;
                                        
                                        // Zoom to the selected route
                                        const bounds = polyline.getBounds();
                                        searchMap.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
                                        
                                        // Check if user already liked this route in Firebase
                                        const user = auth.currentUser;
                                        let alreadyLiked = false;
                                        if (user) {
                                            try {
                                                const likeSnapshot = await database.ref(`userLikes/${user.uid}/routes/${route.id}`).once('value');
                                                alreadyLiked = likeSnapshot.exists();
                                            } catch (error) {
                                                console.error('Error checking like status:', error);
                                            }
                                        }
                                        
                                        const btnState = alreadyLiked ? 
                                            `<button id="route-like-btn-${route.id}" style="background: rgba(107, 155, 158, 0.5); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; font-weight: 600; cursor: default; font-size: 0.9rem;" disabled>‚ù§Ô∏è Liked</button>` :
                                            `<button id="route-like-btn-${route.id}" onclick="toggleLike('routes', '${route.id}')" style="background: var(--accent-color); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 0.9rem;">‚ù§Ô∏è Like Route</button>`;
                                        
                                        // Populate info panel
                                        const infoPanel = document.getElementById('searchInfoPanel');
                                        const infoContent = document.getElementById('searchInfoContent');
                                        
                                        if (infoPanel && infoContent) {
                                            let waypointsHTML = '';
                                            if (route.waypointLabels && route.waypointLabels.length > 0) {
                                                waypointsHTML = '<div style="margin-top: 1rem;"><strong style="color: var(--accent-light);">Route Stops:</strong><ol style="margin: 0.5rem 0; padding-left: 1.5rem; color: #d4d4d4;">';
                                                route.waypointLabels.forEach((label, idx) => {
                                                    waypointsHTML += `<li style="margin: 0.3rem 0;">${label || `Stop ${idx + 1}`}</li>`;
                                                });
                                                waypointsHTML += '</ol></div>';
                                            } else {
                                                waypointsHTML = `<p style="color: #999; margin-top: 1rem;">üìç ${route.waypointCount} waypoints</p>`;
                                            }
                                            
                                            // Get username without count for display
                                            const username = await getUsernameFromId(route.createdBy);
                                            const userDisplay = username === 'Deleted User' ? 
                                                `<span style="color: #999; font-size: 0.85rem;">üë§ Posted by: Deleted User</span>` :
                                                `<span style="color: var(--accent-light); font-size: 0.85rem; cursor: pointer; text-decoration: underline;" onclick="viewUserProfile('${route.createdBy}', '${username}')" title="View ${username}'s profile">üë§ Posted by: ${username}</span>`;
                                            
                                            infoContent.innerHTML = `
                                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.8rem; border-bottom: 2px solid rgba(107, 155, 158, 0.3);">
                                                    <h3 style="color: var(--accent-color); margin: 0; word-wrap: break-word; word-break: break-word; flex: 1;">${route.name}</h3>
                                                    <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                        ${route.category ? `<span style="display: inline-block; background: var(--accent-light); color: white; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">üìÅ ${route.category}</span>` : ''}
                                                        <button onclick="closeRouteInfo()" style="background: rgba(255, 255, 255, 0.1); border: none; color: var(--accent-light); width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0;" onmouseover="this.style.background='rgba(107, 155, 158, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 158, 0.1)'">‚úï</button>
                                                    </div>
                                                </div>
                                                <div style="margin-bottom: 0.5rem;">${userDisplay}</div>
                                                ${route.description ? `<p style="color: #d4d4d4; margin-top: 0.5rem; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word;">${route.description}</p>` : ''}
                                                ${waypointsHTML}
                                                <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(107, 155, 158, 0.2);">
                                                    <p id="route-like-count-${route.id}" style="color: var(--accent-light); font-weight: 600; margin: 0;">‚ù§Ô∏è ${route.likes || 0} fl√¢neurs like this route</p>
                                                    ${btnState}
                                                </div>
                                            `;
                                            infoPanel.style.display = 'block';
                                            // Auto-scroll into view
                                            setTimeout(() => {
                                                infoPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                            }, 100);
                                        }
                                    });
                                    
                                    // Make plain pin clickable to highlight route
                                    plainPin.on('click', function() {
                                        polyline.fire('click');
                                    });
                                    
                                    // Also make numbered markers clickable to highlight route
                                    markers.forEach(marker => {
                                        marker.on('click', function() {
                                            polyline.fire('click');
                                        });
                                    });
                                }
                            });
                            
                            // Initially show all routes on map (filter default is "all")
                            allRoutesData.forEach(routeData => {
                                routeData.polyline.addTo(searchMap);
                                routeData.plainPin.addTo(searchMap);
                            });
                            
                            // If we have a highlightId, filter to show only that route
                            if (highlightId) {
                                allRoutesData.forEach(routeData => {
                                    if (routeData.route.id === highlightId) {
                                        // Keep this route visible and highlighted
                                        routeData.polyline.fire('click');
                                        // Center map on this route with city-level zoom (max zoom 12)
                                        const bounds = routeData.polyline.getBounds();
                                        searchMap.fitBounds(bounds, { padding: [50, 50], maxZoom: 12 });
                                    } else {
                                        // Hide other routes
                                        searchMap.removeLayer(routeData.polyline);
                                        if (searchMap.hasLayer(routeData.plainPin)) {
                                            searchMap.removeLayer(routeData.plainPin);
                                        }
                                    }
                                });
                            }
                            
                            // Category filter functionality
                            const categoryFilter = document.getElementById('categoryFilter');
                            const customCategoryFilterContainer = document.getElementById('customCategoryFilterContainer');
                            const customCategoryFilter = document.getElementById('customCategoryFilter');
                            
                            if (categoryFilter) {
                                // Define all predefined categories (including old format for legacy data)
                                const predefinedCategories = [
                                    'Coffee Shops', 'Tacos', 'Pizza', 'Burgers', 'Asian Cuisine', 'Italian',
                                    'Bakeries & Cafes', 'Bars & Breweries', 'Cocktail Bars', 'Wine Bars',
                                    'Live Music Venues', 'Nightlife', 'Shopping Districts', 'Fashion & Boutiques',
                                    'Bookstores', 'Art Galleries', 'Theater & Performance', 'Museums',
                                    'Historic Sites', 'Architecture', 'Parks & Gardens', 'Scenic Walks',
                                    'Hiking Trails', 'Bike Routes', 'Waterfront', 'Seasonal', 'Photo Spots',
                                    'Spooky & Ghost Tours', 'Holiday Themed', 'Neighborhood Tours', 'Hidden Gems',
                                    'Street Art', 'Markets & Bazaars', 'Cultural Districts', 'Religious Sites',
                                    'Castles & Landmarks', 'Entertainment Districts', 'Fitness & Sports',
                                    'Wellness & Yoga', 'Family Friendly', 'Dog Friendly', 'Accessible Routes',
                                    'Educational Tours', 'Business Districts', 'Bridge Walks',
                                    // Old format categories (for backwards compatibility)
                                    'coffee', 'tacos', 'food', 'bars', 'bookstores', 'shopping', 'clothing', 
                                    'art', 'parks', 'historic', 'other'
                                ];
                                
                                // Collect unique custom categories
                                function getCustomCategories() {
                                    const customCats = new Set();
                                    allRoutesData.forEach(routeData => {
                                        const cat = routeData.route.category;
                                        if (cat && !predefinedCategories.includes(cat)) {
                                            customCats.add(cat);
                                        }
                                    });
                                    return Array.from(customCats).sort();
                                }
                                
                                categoryFilter.addEventListener('change', function() {
                                    const selectedCategory = this.value;
                                    
                                    // Show/hide custom category dropdown
                                    if (selectedCategory === 'User Added') {
                                        const customCats = getCustomCategories();
                                        if (customCats.length === 0) {
                                            customCategoryFilterContainer.style.display = 'none';
                                            // Show message that no custom categories exist
                                            alert('No custom categories have been created yet! Create a route with "Other" category to add your own custom categories.');
                                            // Reset filter to show all
                                            this.value = 'all';
                                            allRoutesData.forEach(routeData => {
                                                searchMap.addLayer(routeData.polyline);
                                                routeData.markers.forEach(m => searchMap.addLayer(m));
                                            });
                                            return;
                                        }
                                        
                                        // Populate custom category dropdown
                                        customCategoryFilter.innerHTML = '<option value="">All Custom Categories</option>' + 
                                            customCats.map(cat => `<option value="${cat}">‚ú® ${cat}</option>`).join('');
                                        customCategoryFilterContainer.style.display = 'block';
                                        
                                        // Show all custom category routes by default
                                        allRoutesData.forEach(routeData => {
                                            const routeCategory = routeData.route.category || '';
                                            const isCustom = routeCategory && !predefinedCategories.includes(routeCategory);
                                            
                                            if (isCustom) {
                                                searchMap.addLayer(routeData.polyline);
                                                if (routeData.plainPin && !searchMap.hasLayer(routeData.plainPin)) {
                                                    searchMap.addLayer(routeData.plainPin);
                                                }
                                            } else {
                                                searchMap.removeLayer(routeData.polyline);
                                                if (routeData.plainPin && searchMap.hasLayer(routeData.plainPin)) {
                                                    searchMap.removeLayer(routeData.plainPin);
                                                }
                                            }
                                        });
                                    } else {
                                        customCategoryFilterContainer.style.display = 'none';
                                        
                                        // Regular category filtering
                                        allRoutesData.forEach(routeData => {
                                            const routeCategory = routeData.route.category || '';
                                            const shouldShow = selectedCategory === 'all' || routeCategory === selectedCategory;
                                            
                                            if (shouldShow) {
                                                searchMap.addLayer(routeData.polyline);
                                                if (routeData.plainPin && !searchMap.hasLayer(routeData.plainPin)) {
                                                    searchMap.addLayer(routeData.plainPin);
                                                }
                                            } else {
                                                searchMap.removeLayer(routeData.polyline);
                                                if (routeData.plainPin && searchMap.hasLayer(routeData.plainPin)) {
                                                    searchMap.removeLayer(routeData.plainPin);
                                                }
                                            }
                                        });
                                    }
                                });
                                
                                // Custom category filter listener
                                if (customCategoryFilter) {
                                    customCategoryFilter.addEventListener('change', function() {
                                        const selectedCustomCat = this.value;
                                        
                                        allRoutesData.forEach(routeData => {
                                            const routeCategory = routeData.route.category || '';
                                            const isCustom = routeCategory && !predefinedCategories.includes(routeCategory);
                                            
                                            let shouldShow = false;
                                            if (selectedCustomCat === '') {
                                                // Show all custom categories
                                                shouldShow = isCustom;
                                            } else {
                                                // Show only selected custom category
                                                shouldShow = routeCategory === selectedCustomCat;
                                            }
                                            
                                            if (shouldShow) {
                                                searchMap.addLayer(routeData.polyline);
                                                if (routeData.plainPin && !searchMap.hasLayer(routeData.plainPin)) {
                                                    searchMap.addLayer(routeData.plainPin);
                                                }
                                            } else {
                                                searchMap.removeLayer(routeData.polyline);
                                                if (routeData.plainPin && searchMap.hasLayer(routeData.plainPin)) {
                                                    searchMap.removeLayer(routeData.plainPin);
                                                }
                                            }
                                        });
                                    });
                                }
                            }
                            
                            // Click map background to reset all routes
                            searchMap.on('click', function(e) {
                                // Only reset if clicking the map itself, not a route
                                if (e.originalEvent.target.classList.contains('leaflet-container') || 
                                    e.originalEvent.target.classList.contains('leaflet-tile')) {
                                    allRoutesData.forEach(r => {
                                        r.polyline.setStyle({ opacity: 0.7, weight: 4, color: '#8DBCC0' });
                                        r.markers.forEach(m => m.setOpacity(1));
                                    });
                                    selectedRoute = null;
                                }
                            });
                        });

                        
                        // Add search autocomplete functionality
                        const searchInput = document.getElementById('mapSearch');
                        const suggestionsDiv = document.getElementById('mapSearchSuggestions');
                        let searchTimeout;
                        
                        if (searchInput && suggestionsDiv) {
                            searchInput.addEventListener('input', function(e) {
                                const query = e.target.value.trim();
                                clearTimeout(searchTimeout);
                                
                                if (query.length < 2) {
                                    suggestionsDiv.style.display = 'none';
                                    return;
                                }
                                
                                searchTimeout = setTimeout(() => {
                                    fetchLocationSuggestions(query, suggestionsDiv, searchMap, searchInput);
                                }, 100);
                            });
                            
                            searchInput.addEventListener('keypress', function(e) {
                                if (e.key === 'Enter' && suggestionsDiv.style.display === 'none') {
                                    searchLocation(searchInput.value, searchMap);
                                }
                            });
                            
                            document.addEventListener('click', function(e) {
                                if (!searchInput.contains(e.target) && !suggestionsDiv.contains(e.target)) {
                                    suggestionsDiv.style.display = 'none';
                                }
                            });
                        }
                    }
                } else if (sectionId === 'swarms') {
                    const mapElement = document.getElementById('swarm-map');
                    // Clean up existing map if it exists
                    if (swarmMap) {
                        swarmMap.remove();
                        swarmMap = null;
                    }
                    if (mapElement) {
                        // Remove Leaflet's internal container reference if it exists
                        if (mapElement._leaflet_id) {
                            delete mapElement._leaflet_id;
                        }
                        // Initialize map
                        swarmMap = L.map(mapElement).setView([39.7392, -104.9903], 13);
                        L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3gifQ.EPETOMFI41QInYccb4Cehg', {
                            tileSize: 512,
                            zoomOffset: -1
                        }).addTo(swarmMap);
                        L.control.attribution({ position: 'bottomright', prefix: false }).addAttribution('¬© <a href="https://www.mapbox.com/">Mapbox</a>').addTo(swarmMap);
                        
                        // Always load/reload swarms from Firebase
                        window.allSwarmMarkersArray = []; // Reset marker array
                        getAllSwarms().then(swarms => {
                            
                            if (swarms.length === 0) {
                                return;
                            }
                            
                            // Get today's date for comparison
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            
                            let validCount = 0;
                            let invalidCount = 0;
                            
                            swarms.forEach(swarm => {
                                // Skip swarms without coordinates
                                if (!swarm.lat || !swarm.lng) {
                                    invalidCount++;
                                    return;
                                }
                                
                                // Skip past swarms (check date AND time)
                                // BUT keep visible for 2 hours after start time as buffer
                                if (swarm.date && swarm.time) {
                                    // Combine date and time into full datetime
                                    const [year, month, day] = swarm.date.split('-');
                                    const [hours, minutes] = swarm.time.split(':');
                                    const swarmDateTime = new Date(year, month - 1, day, hours, minutes);
                                    
                                    // Add 2-hour buffer (7200000 ms = 2 hours)
                                    const swarmEndWithBuffer = new Date(swarmDateTime.getTime() + 7200000);
                                    
                                    // Compare to current moment
                                    const now = new Date();
                                    if (swarmEndWithBuffer < now) {
                                        invalidCount++;
                                        return;
                                    }
                                } else if (swarm.date) {
                                    // If no time specified, just check date
                                    const [year, month, day] = swarm.date.split('-');
                                    const swarmDate = new Date(year, month - 1, day);
                                    if (swarmDate < today) {
                                        invalidCount++;
                                        return;
                                    }
                                }
                                
                                validCount++;
                                
                                const isHighlighted = highlightId !== null && swarm.id === highlightId;
                                
                                // Create custom dark blue pushpin icon
                                const swarmPinIcon = L.divIcon({
                                    className: 'swarm-browse-pin',
                                    html: isHighlighted ? 
                                        '<div style="background: #0056b3; color: white; border-radius: 50% 50% 50% 0; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid #FFD700; transform: rotate(-45deg); box-shadow: 0 4px 12px rgba(0,0,0,0.5);"><span style="transform: rotate(45deg); font-size: 1.2rem;">üõçÔ∏è</span></div>' :
                                        '<div style="background: #0056b3; color: white; border-radius: 50% 50% 50% 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; transform: rotate(-45deg); box-shadow: 0 2px 8px rgba(0,0,0,0.3);"><span style="transform: rotate(45deg);">üõçÔ∏è</span></div>',
                                    iconSize: isHighlighted ? [40, 40] : [32, 32],
                                    iconAnchor: isHighlighted ? [20, 40] : [16, 32]
                                });
                                
                                const participants = swarm.interested || 0;
                                const marker = L.marker([swarm.lat, swarm.lng], { icon: swarmPinIcon }).addTo(swarmMap);
                                window.allSwarmMarkersArray.push(marker); // Store for zoom out
                                
                                // Add additional markers if multiple locations exist
                                if (swarm.locations && swarm.locations.length > 1) {
                                    swarm.locations.slice(1).forEach((location, idx) => {
                                        const additionalMarkerOptions = {
                                            icon: L.divIcon({
                                                className: 'swarm-additional-marker',
                                                html: `<div style="background: rgba(0, 86, 179, 0.9); color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${idx + 2}</div>`,
                                                iconSize: [28, 28],
                                                iconAnchor: [14, 14]
                                            })
                                        };
                                        L.marker([location.lat, location.lng], additionalMarkerOptions).addTo(swarmMap);
                                    });
                                }
                                
                                // Click handler to populate info panel
                                marker.on('click', async function() {
                                    // Zoom to pin location at street level
                                    swarmMap.setView([swarm.lat, swarm.lng], 15);
                                    
                                    const infoPanel = document.getElementById('swarmInfoPanel');
                                    const infoContent = document.getElementById('swarmInfoContent');
                                    
                                    if (infoPanel && infoContent) {
                                        // Check if user already marked interest in Firebase
                                        const user = auth.currentUser;
                                        let alreadyInterested = false;
                                        if (user) {
                                            try {
                                                const interestSnapshot = await database.ref(`userInterests/${user.uid}/swarms/${swarm.id}`).once('value');
                                                alreadyInterested = interestSnapshot.exists();
                                            } catch (error) {
                                                console.error('Error checking interest status:', error);
                                            }
                                        }
                                        
                                        const btnState = alreadyInterested ? 
                                            `<button id="swarm-interest-btn-${swarm.id}" style="background: rgba(107, 155, 158, 0.5); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; font-weight: 600; cursor: default; font-size: 0.9rem;" disabled>‚úì Interested</button>` :
                                            `<button id="swarm-interest-btn-${swarm.id}" onclick="toggleInterest('swarms', '${swarm.id}')" style="background: var(--accent-color); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 0.9rem;">I'm Interested</button>`;
                                        
                                        // Get username without count for display
                                        const username = await getUsernameFromId(swarm.createdBy);
                                        const userDisplay = username === 'Deleted User' ? 
                                            `<p style="color: #999; font-size: 0.85rem; margin: 0.5rem 0;">üë§ Deleted User</p>` :
                                            `<p style="color: var(--accent-light); font-size: 0.85rem; margin: 0.5rem 0; cursor: pointer; text-decoration: underline;" onclick="viewUserProfile('${swarm.createdBy}', '${username}')" title="View ${username}'s profile">üë§ Organized by: ${username}</p>`;
                                        
                                        infoContent.innerHTML = `
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.8rem; border-bottom: 2px solid rgba(107, 155, 158, 0.3);">
                                                <h3 style="color: var(--accent-color); margin: 0; word-wrap: break-word; word-break: break-word; flex: 1;">${swarm.title}</h3>
                                                <div style="display: flex; align-items: center; gap: 0.5rem;">
                                                    <span style="display: inline-block; background: var(--accent-light); color: white; padding: 0.3rem 0.8rem; border-radius: 15px; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">üõçÔ∏è Shopping Swarm</span>
                                                    <button onclick="closeSwarmInfo()" style="background: rgba(255, 255, 255, 0.1); border: none; color: var(--accent-light); width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0;" onmouseover="this.style.background='rgba(107, 155, 158, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.1)'">‚úï</button>
                                                </div>
                                            </div>
                                            ${userDisplay}
                                            <p style="color: #d4d4d4; margin: 0.5rem 0; word-wrap: break-word;"><strong style="color: var(--accent-light);">üìç Meeting Location:</strong> ${swarm.meetingLocation || swarm.location || 'Location TBD'}</p>
                                            ${swarm.locationCount && swarm.locationCount > 1 ? `<p style="color: var(--accent-color); margin: 0.5rem 0; font-weight: 600;"><strong>üéØ Multi-Business Swarm:</strong> ${swarm.locationCount} locations</p>` : ''}
                                            <p style="color: #d4d4d4; margin: 0.5rem 0;"><strong style="color: var(--accent-light);">üìÖ When:</strong> ${swarm.date} at ${swarm.time}</p>
                                            <p style="color: #999; font-size: 0.85rem; margin: 0.3rem 0 0.5rem 0; font-style: italic;">‚è∞ Time shown in organizer's local timezone</p>
                                            ${swarm.duration ? `<p style="color: #d4d4d4; margin: 0.5rem 0;"><strong style="color: var(--accent-light);">‚è±Ô∏è Duration:</strong> ${swarm.duration}</p>` : ''}
                                            ${swarm.description ? `<p style="color: #d4d4d4; margin: 0.8rem 0 0 0; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word;">${swarm.description}</p>` : ''}
                                            ${swarm.identifier ? `<p style="color: #d4d4d4; margin: 0.8rem 0 0 0; word-wrap: break-word;"><strong style="color: var(--accent-light);">üîç Look for:</strong> ${swarm.identifier}</p>` : ''}
                                            ${swarm.postedBy ? `<p style="color: #d4d4d4; margin: 0.5rem 0; word-wrap: break-word;"><strong style="color: var(--accent-light);">üë§ Organizer:</strong> ${swarm.postedBy}</p>` : ''}
                                            ${swarm.createdBy !== (user ? user.uid : null) ? `<button onclick="openMessageModal('${swarm.createdBy}', '${username.replace(/'/g, "\\'")}', 'swarm', '${(swarm.title || '').replace(/'/g, "\\'").replace(/"/g, "&quot;")}')" style="background: var(--accent-color); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; margin: 0.5rem 0; font-size: 0.9rem;">üìß Contact Organizer</button>` : ''}
                                            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(107, 155, 158, 0.2);">
                                                <p id="swarm-interest-count-${swarm.id}" style="color: var(--accent-light); font-weight: 600; margin: 0;">üë• ${participants} fl√¢neurs interested</p>
                                                ${btnState}
                                            </div>
                                        `;
                                        infoPanel.style.display = 'block';
                                        // Auto-scroll into view
                                        setTimeout(() => {
                                            infoPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                        }, 100);
                                    }
                                });
                                
                                // Auto-show info for highlighted swarm
                                if (isHighlighted) {
                                    marker.fire('click');
                                    swarmMap.setView([swarm.lat, swarm.lng], 15); // Street level zoom to match click behavior
                                }
                            });
                        });
                        
                        // Add search autocomplete functionality for swarms
                        const swarmSearchInput = document.getElementById('swarmLocationSearch');
                        const swarmSuggestionsDiv = document.getElementById('swarmSearchSuggestions');
                        let swarmSearchTimeout;
                        
                        if (swarmSearchInput && swarmSuggestionsDiv) {
                            swarmSearchInput.addEventListener('input', function(e) {
                                const query = e.target.value.trim();
                                clearTimeout(swarmSearchTimeout);
                                
                                if (query.length < 2) {
                                    swarmSuggestionsDiv.style.display = 'none';
                                    return;
                                }
                                
                                swarmSearchTimeout = setTimeout(() => {
                                    fetchLocationSuggestions(query, swarmSuggestionsDiv, swarmMap, swarmSearchInput);
                                }, 100);
                            });
                            
                            swarmSearchInput.addEventListener('keypress', function(e) {
                                if (e.key === 'Enter' && swarmSuggestionsDiv.style.display === 'none') {
                                    searchLocation(swarmSearchInput.value, swarmMap);
                                }
                            });
                            
                            document.addEventListener('click', function(e) {
                                if (!swarmSearchInput.contains(e.target) && !swarmSuggestionsDiv.contains(e.target)) {
                                    swarmSuggestionsDiv.style.display = 'none';
                                }
                            });
                        }
                    }
                } else if (sectionId === 'events') {
                    // Initialize event map
                    const eventMapElement = document.getElementById('event-map');
                    // Clean up existing map if it exists
                    if (eventMap) {
                        eventMap.remove();
                        eventMap = null;
                    }
                    if (eventMapElement) {
                        // Remove Leaflet's internal container reference if it exists
                        if (eventMapElement._leaflet_id) {
                            delete eventMapElement._leaflet_id;
                        }
                        // Initialize map
                        eventMap = L.map(eventMapElement).setView([39.7392, -104.9903], 13);
                        L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3gifQ.EPETOMFI41QInYccb4Cehg', {
                            tileSize: 512,
                            zoomOffset: -1
                        }).addTo(eventMap);
                        L.control.attribution({ position: 'bottomright', prefix: false }).addAttribution('¬© <a href="https://www.mapbox.com/">Mapbox</a>').addTo(eventMap);
                        
                        // Always load/reload events from Firebase
                        getAllEvents().then(events => {
                            console.log('PWA DEBUG: Loading events for map, total count:', events.length);
                            
                            window.allEventMarkersArray = []; // Reset marker array
                            
                            if (events.length === 0) {
                                console.log('PWA DEBUG: No events found in database');
                                return;
                            }
                            
                            // Get today's date for comparison
                            const today = new Date();
                            today.setHours(0, 0, 0, 0);
                            
                            let validCount = 0;
                            let invalidCount = 0;
                            
                            events.forEach(event => {
                                // Skip events without coordinates
                                if (!event.lat || !event.lng) {
                                    console.log('PWA DEBUG: Skipping event (no coordinates):', event.name);
                                    invalidCount++;
                                    return;
                                }
                                
                                // Skip past events (check end time first, then start time)
                                // BUT keep visible for 2 hours after end time as buffer
                                const now = new Date();
                                
                                console.log('PWA DEBUG: Checking event:', event.name, {
                                    startDate: event.startDate,
                                    startTime: event.startTime,
                                    endDate: event.endDate,
                                    endTime: event.endTime,
                                    recurring: event.recurring
                                });
                                
                                if (event.endDate && event.endTime) {
                                    // Event has end date+time - use that PLUS 2-hour buffer
                                    const [year, month, day] = event.endDate.split('-');
                                    const [hours, minutes] = event.endTime.split(':');
                                    const endDateTime = new Date(year, month - 1, day, hours, minutes);
                                    
                                    // Add 2-hour buffer (7200000 ms = 2 hours)
                                    const endWithBuffer = new Date(endDateTime.getTime() + 7200000);
                                    
                                    console.log('PWA DEBUG: Comparing endDateTime+buffer:', endWithBuffer, 'vs now:', now, 'isPast:', endWithBuffer < now);
                                    if (endWithBuffer < now) {
                                        console.log('PWA DEBUG: FILTERED - Event ended (has endDate+endTime)');
                                        invalidCount++;
                                        return;
                                    }
                                } else if (event.endDate) {
                                    // Event has end date only - add buffer to end of day
                                    const [year, month, day] = event.endDate.split('-');
                                    const endDate = new Date(year, month - 1, day, 23, 59, 59);
                                    const endWithBuffer = new Date(endDate.getTime() + 7200000);
                                    
                                    console.log('PWA DEBUG: Comparing endDate+buffer:', endWithBuffer, 'vs now:', now, 'isPast:', endWithBuffer < now);
                                    if (endWithBuffer < now) {
                                        console.log('PWA DEBUG: FILTERED - Event ended (has endDate only)');
                                        invalidCount++;
                                        return;
                                    }
                                } else if (event.startDate && event.startTime) {
                                    // No end date - use start date+time PLUS 2-hour buffer
                                    const [year, month, day] = event.startDate.split('-');
                                    const [hours, minutes] = event.startTime.split(':');
                                    const startDateTime = new Date(year, month - 1, day, hours, minutes);
                                    const startWithBuffer = new Date(startDateTime.getTime() + 7200000);
                                    
                                    console.log('PWA DEBUG: Comparing startDateTime+buffer:', startWithBuffer, 'vs now:', now, 'isPast:', startWithBuffer < now);
                                    if (startWithBuffer < now) {
                                        console.log('PWA DEBUG: FILTERED - Event started in past (has startDate+startTime, no end)');
                                        invalidCount++;
                                        return;
                                    }
                                } else if (event.startDate) {
                                    // Only start date, no times - use end of day + buffer
                                    const [year, month, day] = event.startDate.split('-');
                                    const startDate = new Date(year, month - 1, day, 23, 59, 59);
                                    const startWithBuffer = new Date(startDate.getTime() + 7200000);
                                    
                                    console.log('PWA DEBUG: Comparing startDate+buffer:', startWithBuffer, 'vs now:', now, 'isPast:', startWithBuffer < now);
                                    if (startWithBuffer < now) {
                                        console.log('PWA DEBUG: FILTERED - Event date in past (has startDate only)');
                                        invalidCount++;
                                        return;
                                    }
                                }
                                
                                validCount++;
                                console.log('PWA DEBUG: ‚úì Event PASSED all filters:', event.name);
                                
                                const isHighlighted = highlightId !== null && event.id === highlightId;
                                
                                // Create custom dark blue pushpin icon
                                const eventPinIcon = L.divIcon({
                                    className: 'event-browse-pin',
                                    html: isHighlighted ? 
                                        '<div style="background: #0056b3; color: white; border-radius: 50% 50% 50% 0; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 3px solid #FFD700; transform: rotate(-45deg); box-shadow: 0 4px 12px rgba(0,0,0,0.5);"><span style="transform: rotate(45deg); font-size: 1.2rem;">üéâ</span></div>' :
                                        '<div style="background: #0056b3; color: white; border-radius: 50% 50% 50% 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; transform: rotate(-45deg); box-shadow: 0 2px 8px rgba(0,0,0,0.3);"><span style="transform: rotate(45deg);">üéâ</span></div>',
                                    iconSize: isHighlighted ? [40, 40] : [32, 32],
                                    iconAnchor: isHighlighted ? [20, 40] : [16, 32]
                                });
                                
                                const marker = L.marker([event.lat, event.lng], { icon: eventPinIcon }).addTo(eventMap);
                                console.log('PWA DEBUG: Added marker for event:', event.name, 'at', event.lat, event.lng);
                                window.allEventMarkersArray.push(marker); // Store for zoom out
                                
                                // Click handler to populate info panel
                                marker.on('click', async function() {
                                    // Zoom to pin location at street level
                                    eventMap.setView([event.lat, event.lng], 15);
                                    
                                    const infoPanel = document.getElementById('eventInfoPanel');
                                    const infoContent = document.getElementById('eventInfoContent');
                                    
                                    if (infoPanel && infoContent) {
                                        let dateTimeStr = `${event.startDate} at ${event.startTime}`;
                                        if (event.endDate || event.endTime) {
                                            dateTimeStr += ` - ${event.endDate || event.startDate}${event.endTime ? ' at ' + event.endTime : ''}`;
                                        }
                                        
                                        // Check if user already marked interest in Firebase
                                        const user = auth.currentUser;
                                        let alreadyInterested = false;
                                        if (user) {
                                            try {
                                                const interestSnapshot = await database.ref(`userInterests/${user.uid}/events/${event.id}`).once('value');
                                                alreadyInterested = interestSnapshot.exists();
                                            } catch (error) {
                                                console.error('Error checking interest status:', error);
                                            }
                                        }
                                        
                                        const btnState = alreadyInterested ? 
                                            `<button id="event-interest-btn-${event.id}" style="background: rgba(107, 155, 158, 0.5); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; font-weight: 600; cursor: default; font-size: 0.9rem;" disabled>‚úì Interested</button>` :
                                            `<button id="event-interest-btn-${event.id}" onclick="toggleInterest('events', '${event.id}')" style="background: var(--accent-color); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 0.9rem;">I'm Interested</button>`;
                                        
                                        // Get username without count for display
                                        const username = await getUsernameFromId(event.createdBy);
                                        const userDisplay = username === 'Deleted User' ? 
                                            `<p style="color: #999; font-size: 0.85rem; margin: 0.5rem 0;">üë§ Deleted User</p>` :
                                            `<p style="color: var(--accent-light); font-size: 0.85rem; margin: 0.5rem 0; cursor: pointer; text-decoration: underline;" onclick="viewUserProfile('${event.createdBy}', '${username}')" title="View ${username}'s profile">üë§ Posted by: ${username}</p>`;
                                        
                                        infoContent.innerHTML = `
                                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.8rem; border-bottom: 2px solid rgba(107, 155, 158, 0.3);">
                                                <h3 style="color: var(--accent-color); margin: 0; word-wrap: break-word; word-break: break-word; flex: 1;">${event.name}</h3>
                                                <button onclick="closeEventInfo()" style="background: rgba(255, 255, 255, 0.1); border: none; color: var(--accent-light); width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: all 0.2s; flex-shrink: 0;" onmouseover="this.style.background='rgba(107, 155, 158, 0.3)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.1)'">‚úï</button>
                                            </div>
                                            ${userDisplay}
                                            <p style="color: #d4d4d4; margin: 0.5rem 0; word-wrap: break-word;"><strong style="color: var(--accent-light);">üìç Location:</strong> ${event.location}</p>
                                            <p style="color: #d4d4d4; margin: 0.5rem 0;"><strong style="color: var(--accent-light);">üìÖ When:</strong> ${dateTimeStr}</p>
                                            <p style="color: #999; font-size: 0.85rem; margin: 0.3rem 0 0.5rem 0; font-style: italic;">‚è∞ Time shown in organizer's local timezone</p>
                                            ${event.description ? `<p style="color: #d4d4d4; margin: 0.8rem 0; word-wrap: break-word; word-break: break-word; overflow-wrap: break-word;">${event.description}</p>` : ''}
                                            ${event.postedBy ? `<p style="color: #d4d4d4; margin: 0.5rem 0; word-wrap: break-word;"><strong style="color: var(--accent-light);">üë§ Contact Name:</strong> ${event.postedBy}</p>` : ''}
                                            ${event.createdBy !== (user ? user.uid : null) ? `<button onclick="openMessageModal('${event.createdBy}', '${username.replace(/'/g, "\\'")}', 'event', '${(event.name || '').replace(/'/g, "\\'").replace(/"/g, "&quot;")}')" style="background: var(--accent-color); color: white; border: none; padding: 0.6rem 1.2rem; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; margin: 0.5rem 0; font-size: 0.9rem;">üìß Contact Organizer</button>` : ''}
                                            ${event.website ? `<p style="color: #d4d4d4; margin: 0.5rem 0; word-wrap: break-word;"><strong style="color: var(--accent-light);">üîó Website:</strong> <a href="${event.website}" target="_blank" style="color: var(--accent-light); word-break: break-all;">${event.website}</a></p>` : ''}
                                            ${event.maxParticipants ? `<p style="color: #d4d4d4; margin: 0.5rem 0;"><strong style="color: var(--accent-light);">üë• Max Participants:</strong> ${event.maxParticipants}</p>` : ''}
                                            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid rgba(107, 155, 158, 0.2);">
                                                <p id="event-interest-count-${event.id}" style="color: var(--accent-light); font-weight: 600; margin: 0;">üë• ${event.interested || 0} fl√¢neurs interested</p>
                                                ${btnState}
                                            </div>
                                        `;
                                        infoPanel.style.display = 'block';
                                        // Auto-scroll into view
                                        setTimeout(() => {
                                            infoPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                                        }, 100);
                                    }
                                });
                                
                                // Auto-show info for highlighted event
                                if (isHighlighted) {
                                    marker.fire('click');
                                    eventMap.setView([event.lat, event.lng], 15); // Street level zoom to match click behavior
                                }
                            });
                            
                            console.log('PWA DEBUG: Event loading complete. Valid events:', validCount, 'Invalid/filtered:', invalidCount, 'Total markers:', window.allEventMarkersArray.length);
                        });
                    }
                    
                    // Add autocomplete for events search
                    const eventSearchInput = document.getElementById('eventLocationSearch');
                    const eventSuggestionsDiv = document.getElementById('eventSearchSuggestions');
                    let eventSearchTimeout;
                    
                    if (eventSearchInput && eventSuggestionsDiv) {
                        eventSearchInput.addEventListener('input', function(e) {
                            const query = e.target.value.trim();
                            clearTimeout(eventSearchTimeout);
                            
                            if (query.length < 2) {
                                eventSuggestionsDiv.style.display = 'none';
                                return;
                            }
                            
                            eventSearchTimeout = setTimeout(() => {
                                fetchLocationSuggestions(query, eventSuggestionsDiv, eventMap, eventSearchInput);
                            }, 100);
                        });
                        
                        eventSearchInput.addEventListener('keypress', function(e) {
                            if (e.key === 'Enter' && eventSuggestionsDiv.style.display === 'none') {
                                searchLocation(eventSearchInput.value, eventMap);
                            }
                        });
                        
                        document.addEventListener('click', function(e) {
                            if (!eventSearchInput.contains(e.target) && !eventSuggestionsDiv.contains(e.target)) {
                                eventSuggestionsDiv.style.display = 'none';
                            }
                        });
                    }
                }
            }, 500);
        }
        
        // Make toggleSection globally accessible immediately
        window.toggleSection = toggleSection;
        
        async function addWaypoint(latlng) {
            const waypointNumber = routeCoordinates.length + 1;
            const numberIcon = L.divIcon({
                className: 'numbered-marker',
                html: `<div style="background: #0056b3; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">${waypointNumber}</div>`,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });
            
            const marker = L.marker(latlng, { icon: numberIcon }).addTo(journeyMap);
            routeMarkers.push(marker);
            routeCoordinates.push([latlng.lat, latlng.lng]);
            waypointLabels.push(''); // Initialize empty label
            
            // Show and update waypoint labels container
            const labelsContainer = document.getElementById('waypointLabelsContainer');
            const labelsList = document.getElementById('waypointLabelsList');
            if (labelsContainer && labelsList) {
                labelsContainer.style.display = 'block';
                
                const labelInput = document.createElement('div');
                labelInput.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
                labelInput.innerHTML = `
                    <span style="color: var(--accent-light); font-weight: 600; min-width: 30px;">${waypointNumber}.</span>
                    <input type="text" 
                           id="waypointLabel${waypointNumber}" 
                           placeholder="Loading location..."
                           maxlength="50"
                           required
                           style="flex: 1; padding: 0.5rem; background: rgba(40, 40, 40, 0.8); border: 1px solid rgba(107, 155, 158, 0.3); border-radius: 8px; color: white; font-size: 0.9rem;">
                `;
                labelsList.appendChild(labelInput);
                
                // Get business name via reverse geocoding
                const input = document.getElementById(`waypointLabel${waypointNumber}`);
                const placeName = await reverseGeocode(latlng.lat, latlng.lng);
                
                if (placeName) {
                    // Extract just the business/place name (first part before comma)
                    const shortName = placeName.split(',')[0].trim();
                    input.value = shortName;
                    input.placeholder = "e.g., Blue Bottle Coffee, Tattered Cover, etc.";
                    waypointLabels[waypointNumber - 1] = shortName;
                } else {
                    input.placeholder = "e.g., Blue Bottle Coffee, Tattered Cover, etc.";
                }
                
                // Update waypointLabels array when input changes
                input.addEventListener('input', (e) => {
                    waypointLabels[waypointNumber - 1] = e.target.value;
                    // Visual feedback for empty labels
                    if (e.target.value.trim() === '') {
                        e.target.style.borderColor = 'rgba(220, 38, 38, 0.6)';
                    } else {
                        e.target.style.borderColor = 'rgba(107, 155, 158, 0.3)';
                    }
                });
                
                // Initial check if label is empty
                if (!input.value || input.value.trim() === '') {
                    input.style.borderColor = 'rgba(220, 38, 38, 0.6)';
                }
            }
            
            if (routePath) {
                journeyMap.removeLayer(routePath);
            }
            
            if (routeCoordinates.length > 1) {
                routePath = L.polyline(routeCoordinates, { color: 'var(--accent-color)', weight: 4 }).addTo(journeyMap);
            }
            
            showToast(`Waypoint ${waypointNumber} added!`);
        }
        
        function clearRoute() {
            routeMarkers.forEach(marker => journeyMap.removeLayer(marker));
            if (routePath) journeyMap.removeLayer(routePath);
            routeMarkers = [];
            routeCoordinates = [];
            waypointLabels = [];
            routePath = null;
            
            // Clear and hide waypoint labels container
            const labelsContainer = document.getElementById('waypointLabelsContainer');
            const labelsList = document.getElementById('waypointLabelsList');
            if (labelsContainer && labelsList) {
                labelsContainer.style.display = 'none';
                labelsList.innerHTML = '';
            }
            
            showToast('Route cleared!');
        }
        
        function clearSwarm() {
            // Clear all markers from map
            if (window.swarmMarkers && journeyMap) {
                window.swarmMarkers.forEach(marker => {
                    journeyMap.removeLayer(marker);
                });
            }
            
            // Reset all swarm data
            window.swarmMarkers = [];
            window.swarmLocations = [];
            window.swarmBusinessLabels = [];
            window.swarmMultiBusinessMode = false;
            
            // Clear and hide business labels container
            const labelsContainer = document.getElementById('swarmBusinessLabelsContainer');
            const labelsList = document.getElementById('swarmBusinessLabelsList');
            if (labelsContainer) labelsContainer.style.display = 'none';
            if (labelsList) labelsList.innerHTML = '';
            
            // Update count display
            updateBusinessCount();
            
            // Disable save button
            const saveBtn = document.getElementById('saveSwarmMapBtn');
            if (saveBtn) saveBtn.disabled = true;
            
            showToast('Swarm cleared!');
        }
        
        function clearEvent() {
            // Clear marker from map
            if (window.eventMarker && journeyMap) {
                journeyMap.removeLayer(window.eventMarker);
            }
            
            // Reset event data
            window.eventMarker = null;
            window.eventLocation = null;
            
            // Disable save button
            const saveBtn = document.getElementById('saveEventMapBtn');
            if (saveBtn) saveBtn.disabled = true;
            
            showToast('Event cleared!');
        }
        
        // Fetch location suggestions using Mapbox Geocoding API
        function fetchLocationSuggestions(query, suggestionsDiv, map, inputElement) {
            const accessToken = 'pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3gifQ.EPETOMFI41QInYccb4Cehg';
            const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${accessToken}&country=us&limit=8&types=place,address,poi`;
            
            fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data.features && data.features.length > 0) {
                    suggestionsDiv.innerHTML = '';
                    data.features.forEach(result => {
                        const item = document.createElement('div');
                        item.style.cssText = 'padding: 1rem; color: #d4d4d4; cursor: pointer; border-bottom: 1px solid rgba(107, 155, 158, 0.1); transition: background 0.2s;';
                        item.onmouseover = () => item.style.background = 'rgba(107, 155, 158, 0.2)';
                        item.onmouseout = () => item.style.background = '';
                        
                        const main = document.createElement('div');
                        main.style.cssText = 'font-weight: 600; color: var(--accent-light);';
                        main.textContent = result.text || result.place_name.split(',')[0];
                        
                        const detail = document.createElement('div');
                        detail.style.cssText = 'font-size: 0.9rem; color: #999; margin-top: 0.2rem;';
                        detail.textContent = result.place_name;
                        
                        item.appendChild(main);
                        item.appendChild(detail);
                        
                        item.addEventListener('click', function() {
                            const lon = result.center[0];
                            const lat = result.center[1];
                            
                            // Only update map if map exists
                            if (map) {
                                map.setView([lat, lon], 15);
                                
                                // Check if this is for swarm or event map and store location
                                if (map === window.swarmMap) {
                                    // Remove old marker if exists
                                    if (window.swarmMarker) {
                                        map.removeLayer(window.swarmMarker);
                                    }
                                    // Add new marker
                                    window.swarmMarker = L.marker([lat, lon])
                                        .addTo(map)
                                        .bindPopup(`<strong>${result.place_name}</strong>`)
                                        .openPopup();
                                    // Store location
                                    window.swarmLocation = { lat: lat, lng: lon, address: result.place_name };
                                    // Enable Save Swarm button
                                    const saveBtn = document.getElementById('saveSwarmMapBtn');
                                    if (saveBtn) saveBtn.disabled = false;
                                } else if (map === window.eventMap) {
                                    // Remove old marker if exists
                                    if (window.eventMarker) {
                                        map.removeLayer(window.eventMarker);
                                    }
                                    // Add new marker
                                    window.eventMarker = L.marker([lat, lon])
                                        .addTo(map)
                                        .bindPopup(`<strong>${result.place_name}</strong>`)
                                        .openPopup();
                                    // Store location
                                    window.eventLocation = { lat: lat, lng: lon, address: result.place_name };
                                    // Enable Save Event button
                                    const saveBtn = document.getElementById('saveEventMapBtn');
                                    if (saveBtn) saveBtn.disabled = false;
                                } else {
                                    // Journey map or other - just add marker
                                    L.marker([lat, lon])
                                        .addTo(map)
                                        .bindPopup(`<strong>${result.place_name}</strong>`)
                                        .openPopup();
                                }
                            }
                            
                            suggestionsDiv.style.display = 'none';
                            inputElement.value = result.place_name;
                            showToast(`Found: ${result.text}`);
                        });
                        
                        suggestionsDiv.appendChild(item);
                    });
                    suggestionsDiv.style.display = 'block';
                } else {
                    suggestionsDiv.style.display = 'none';
                }
            })
            .catch(error => {
                console.error('Autocomplete error:', error);
                suggestionsDiv.style.display = 'none';
            });
        }
        
        // Search location using Mapbox Geocoding API
        function searchLocation(query, map) {
            if (!query || query.trim() === '') {
                showToast('Please enter a location to search');
                return;
            }
            
            const accessToken = 'pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3gifQ.EPETOMFI41QInYccb4Cehg';
            const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(query)}.json?access_token=${accessToken}&country=us&limit=1`;
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.features && data.features.length > 0) {
                        const result = data.features[0];
                        const lon = result.center[0];
                        const lat = result.center[1];
                        
                        const isZipCode = /^\d{5}$/.test(query.trim());
                        const zoom = isZipCode ? 13 : 15;
                        
                        map.setView([lat, lon], zoom);
                        
                        L.marker([lat, lon])
                            .addTo(map)
                            .bindPopup(`<strong>${result.place_name}</strong>`)
                            .openPopup();
                        
                        const locationName = result.text || result.place_name.split(',')[0];
                        showToast(`Found: ${locationName}`);
                    } else {
                        showToast('Location not found. Try being more specific.');
                    }
                })
                .catch(error => {
                    console.error('Search error:', error);
                    showToast('Search failed. Please try again.');
                });
        }
        
        // Open Save Route Modal
        function openSaveRouteModal() {
            if (routeCoordinates.length < 2) {
                showToast('Please add at least 2 waypoints!');
                return;
            }
            
            // Validate that all waypoints have labels BEFORE opening modal
            const emptyLabels = waypointLabels.filter((label, idx) => !label || label.trim() === '');
            if (emptyLabels.length > 0) {
                showToast('Please label all waypoints before saving!');
                return;
            }
            
            const modal = document.createElement('div');
            modal.id = 'saveRouteModal';
            modal.style.cssText = 'position: fixed; z-index: 10001; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center;';
            
            modal.innerHTML = `
                <div style="background: rgba(25, 25, 25, 0.98); border-radius: 20px; padding: 2rem; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; border: 2px solid rgba(107, 155, 158, 0.3);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
                        <h2 style="color: var(--accent-color);">Save Your Route</h2>
                        <span onclick="document.getElementById('saveRouteModal').remove()" style="font-size: 2rem; color: #d4d4d4; cursor: pointer; transition: color 0.3s;">&times;</span>
                    </div>
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 500;">Route Name *</label>
                        <input type="text" id="routeName" placeholder="e.g., Morning Coffee Trail" style="width: 100%; padding: 0.8rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif;">
                    </div>
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 500;">Description</label>
                        <textarea id="routeDescription" rows="3" placeholder="Describe your route..." style="width: 100%; padding: 0.8rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif;"></textarea>
                    </div>
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 500;">Category</label>
                        <select id="routeCategory" onchange="toggleCustomRouteCategory()" style="width: 100%; padding: 0.8rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif;">
                            <option value="">Select a category...</option>
                            <option value="Coffee Shops">‚òï Coffee Shops</option>
                            <option value="Tacos">üåÆ Tacos</option>
                            <option value="Pizza">üçï Pizza</option>
                            <option value="Burgers">üçî Burgers</option>
                            <option value="Asian Cuisine">üçú Asian Cuisine</option>
                            <option value="Italian">üçù Italian</option>
                            <option value="Bakeries & Cafes">ü•ê Bakeries & Cafes</option>
                            <option value="Bars & Breweries">üç∫ Bars & Breweries</option>
                            <option value="Cocktail Bars">üç∏ Cocktail Bars</option>
                            <option value="Wine Bars">üç∑ Wine Bars</option>
                            <option value="Live Music Venues">üéµ Live Music Venues</option>
                            <option value="Nightlife">üåÉ Nightlife</option>
                            <option value="Shopping Districts">üõçÔ∏è Shopping Districts</option>
                            <option value="Fashion & Boutiques">üëï Fashion & Boutiques</option>
                            <option value="Bookstores">üìö Bookstores</option>
                            <option value="Art Galleries">üé® Art Galleries</option>
                            <option value="Theater & Performance">üé≠ Theater & Performance</option>
                            <option value="Museums">üèõÔ∏è Museums</option>
                            <option value="Historic Sites">üè∫ Historic Sites</option>
                            <option value="Architecture">‚õ™ Architecture</option>
                            <option value="Parks & Gardens">üå≥ Parks & Gardens</option>
                            <option value="Scenic Walks">üèûÔ∏è Scenic Walks</option>
                            <option value="Hiking Trails">üö∂ Hiking Trails</option>
                            <option value="Bike Routes">üö¥ Bike Routes</option>
                            <option value="Waterfront">üèñÔ∏è Waterfront</option>
                            <option value="Seasonal">üå∏ Seasonal (Cherry Blossoms, Fall Colors, etc.)</option>
                            <option value="Photo Spots">üì∏ Photo Spots</option>
                            <option value="Spooky & Ghost Tours">üéÉ Spooky & Ghost Tours</option>
                            <option value="Holiday Themed">üéÑ Holiday Themed</option>
                            <option value="Neighborhood Tours">üè† Neighborhood Tours</option>
                            <option value="Hidden Gems">üíé Hidden Gems</option>
                            <option value="Street Art">üé™ Street Art</option>
                            <option value="Markets & Bazaars">üõí Markets & Bazaars</option>
                            <option value="Cultural Districts">üåç Cultural Districts</option>
                            <option value="Religious Sites">üïå Religious Sites</option>
                            <option value="Castles & Landmarks">üè∞ Castles & Landmarks</option>
                            <option value="Entertainment Districts">üé° Entertainment Districts</option>
                            <option value="Fitness & Sports">üèãÔ∏è Fitness & Sports</option>
                            <option value="Wellness & Yoga">üßò Wellness & Yoga</option>
                            <option value="Family Friendly">üë∂ Family Friendly</option>
                            <option value="Dog Friendly">üêï Dog Friendly</option>
                            <option value="Accessible Routes">‚ôø Accessible Routes</option>
                            <option value="Educational Tours">üéì Educational Tours</option>
                            <option value="Business Districts">üè¢ Business Districts</option>
                            <option value="Bridge Walks">üåâ Bridge Walks</option>
                            <option value="Other">‚ú® Other</option>
                        </select>
                    </div>
                    <div id="customRouteCategoryField" style="margin-bottom: 1.5rem; display: none;">
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 500;">Custom Category</label>
                        <input type="text" id="customRouteCategory" maxlength="50" style="width: 100%; padding: 0.8rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-family: 'Poppins', sans-serif;" placeholder="Enter custom category (e.g., Horror Walk, Vintage Shops)">
                    </div>
                    <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 2rem;">
                        <button onclick="document.getElementById('saveRouteModal').remove()" style="padding: 0.8rem 2rem; border: none; border-radius: 25px; cursor: pointer; font-weight: 600; background: rgba(60, 60, 60, 0.9); color: #d4d4d4;">Cancel</button>
                        <button onclick="confirmSaveRoute()" style="padding: 0.8rem 2rem; border: none; border-radius: 25px; cursor: pointer; font-weight: 600; background: linear-gradient(135deg, var(--accent-color), var(--accent-light)); color: white;">Save Route</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Pre-populate fields if editing
            if (window.editingRouteData) {
                document.getElementById('routeName').value = window.editingRouteData.name || '';
                document.getElementById('routeDescription').value = window.editingRouteData.description || '';
                
                // Handle category - select it from dropdown or use custom
                const category = window.editingRouteData.category || '';
                const categorySelect = document.getElementById('routeCategory');
                
                // Check if category exists in predefined list
                let categoryExists = false;
                for (let option of categorySelect.options) {
                    if (option.value === category) {
                        categorySelect.value = category;
                        categoryExists = true;
                        break;
                    }
                }
                
                // If category doesn't exist in dropdown, use "Other" and put in custom field
                if (!categoryExists && category) {
                    categorySelect.value = 'Other';
                    toggleCustomRouteCategory(); // Show custom field
                    setTimeout(() => {
                        document.getElementById('customRouteCategory').value = category;
                    }, 50);
                }
                
                // Update modal title
                document.querySelector('#saveRouteModal h2').textContent = 'Update Your Route';
            }
        }
        
        async function confirmSaveRoute() {
            // Check if user is banned
            const isBanned = await checkIfBanned();
            if (isBanned) {
                showToast('Your account has been suspended. Contact support for assistance.');
                return;
            }
            
            const name = document.getElementById('routeName').value;
            if (!name) {
                showToast('Please enter a route name!');
                return;
            }
            
            if (routeCoordinates.length < 2) {
                showToast('Please add at least 2 waypoints to your route!');
                return;
            }
            
            // Validate that all waypoints have labels
            const emptyLabels = waypointLabels.filter((label, idx) => !label || label.trim() === '');
            if (emptyLabels.length > 0) {
                showToast('Please label all waypoints before saving!');
                return;
            }
            
            const description = document.getElementById('routeDescription')?.value || '';
            let category = document.getElementById('routeCategory')?.value || '';
            
            // If "Other" is selected, use the custom category input
            if (category === 'Other') {
                const customCategory = document.getElementById('customRouteCategory')?.value.trim();
                if (customCategory) {
                    category = customCategory;
                } else {
                    showToast('Please enter a custom category!');
                    return;
                }
            }
            
            const user = auth.currentUser;
            const displayName = user.displayName || user.email.split('@')[0];
            
            // Get street-following route geometry from Mapbox Directions API
            showToast('Calculating route along streets...');
            let streetGeometry = null;
            
            try {
                // Format coordinates for Mapbox API (lng,lat format)
                const coords = routeCoordinates.map(c => `${c[1]},${c[0]}`).join(';');
                const mapboxToken = 'pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3gifQ.EPETOMFI41QInYccb4Cehg';
                const url = `https://api.mapbox.com/directions/v5/mapbox/walking/${coords}?geometries=geojson&access_token=${mapboxToken}`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.routes && data.routes.length > 0) {
                    // Store the street-following geometry
                    streetGeometry = data.routes[0].geometry.coordinates;
                    console.log('‚úÖ Street route calculated:', streetGeometry.length, 'points');
                } else {
                    console.warn('‚ö†Ô∏è No route returned from Mapbox, using straight lines');
                }
            } catch (error) {
                console.error('‚ùå Error getting street route:', error);
                showToast('Note: Route will use straight lines (street routing unavailable)');
            }
            
            const routeData = {
                name: name,
                description: description,
                category: category,
                waypoints: routeCoordinates, // Original waypoints for markers
                streetGeometry: streetGeometry, // Street-following path for line
                waypointLabels: waypointLabels, // Save custom labels
                waypointCount: routeCoordinates.length,
                likes: 0, // Initialize likes counter
                created: new Date().toISOString(),
                createdBy: user.uid,
                createdByName: displayName,
                createdByEmail: user.email
            };
            
            // Save to Firebase
            try {
                if (!window.database) {
                    throw new Error('Firebase database not initialized');
                }
                
                // Check if we're editing an existing route or creating new
                if (window.editingRouteId) {
                    // UPDATE existing route
                    const routeRef = window.database.ref(`routes/${window.editingRouteId}`);
                    await routeRef.update(routeData);
                    
                    document.getElementById('saveRouteModal').remove();
                    showToast(`Route "${name}" updated successfully!`);
                    
                    // Clear editing flags
                    window.editingRouteId = null;
                    window.editingRouteData = null;
                    
                    // Close the editing map
                    const modal = document.getElementById('fullscreen-journey-map');
                    if (modal) {
                        modal.style.display = 'none';
                        modal.remove();
                        document.body.classList.remove('choreography-active');
                        
                        // Remove all map click handlers before nulling
                        if (journeyMap) {
                            journeyMap.off('click');
                        }
                        journeyMap = null;
                        
                        // Clear route data
                        routeCoordinates = [];
                        waypointLabels = [];
                        routeMarkers = [];
                    }
                    
                    // Open dashboard to show updated route
                    openDashboard();
                } else {
                    // CREATE new route
                    const routesRef = window.database.ref('routes');
                    const newRouteRef = await routesRef.push(routeData);
                    const newRouteId = newRouteRef.key;
                    
                    document.getElementById('saveRouteModal').remove();
                    showToast(`Route "${name}" saved successfully!`);
                    
                    // Close the creation map and open browse routes with the new route highlighted
                    if (newRouteId) {
                        // Close creation section
                        const modal = document.getElementById('fullscreen-journey-map');
                        if (modal) {
                            modal.style.display = 'none';
                            modal.remove();
                            document.body.classList.remove('choreography-active');
                            
                            // Remove all map click handlers before nulling
                            if (journeyMap) {
                                journeyMap.off('click');
                            }
                            journeyMap = null;
                            
                            // Clear route data so it doesn't persist on next create
                            routeCoordinates = [];
                            waypointLabels = [];
                            routeMarkers = [];
                        }
                        // Open browse routes immediately showing the new route
                        toggleSection('search', newRouteId);
                    }
                }
            } catch (error) {
                console.error('‚ùå Error saving route:', error);
                console.error('Route data:', routeData);
                showToast('Error saving route: ' + error.message);
            }
        }
        
        // Make route functions globally accessible
        window.clearRoute = clearRoute;
        window.clearSwarm = clearSwarm;
        window.clearEvent = clearEvent;
        window.openSaveRouteModal = openSaveRouteModal;
        window.confirmSaveRoute = confirmSaveRoute;
        
        // Helper function to get username from userId
        async function getUsernameFromId(userId) {
            try {
                // PRIORITY 1: If it's the current user, always use their displayName first
                if (auth.currentUser && auth.currentUser.uid === userId) {
                    if (auth.currentUser.displayName) {
                        console.log('Using displayName for current user:', auth.currentUser.displayName);
                        return auth.currentUser.displayName;
                    }
                }
                
                // PRIORITY 2: Search usernames database for this userId
                const snapshot = await database.ref('usernames').once('value');
                let foundUsername = null;
                snapshot.forEach((child) => {
                    if (child.val() === userId) {
                        foundUsername = child.key;
                        console.log('Found username in database:', foundUsername, 'for userId:', userId);
                    }
                });
                
                if (foundUsername) {
                    return foundUsername;
                }
                
                // PRIORITY 3: Last resort
                console.log('No username found for userId:', userId);
                return 'Unknown User';
            } catch (error) {
                console.error('Error getting username:', error);
                return 'Unknown User';
            }
        }
        
        // Helper function to count user's total routes
        async function getUserRouteCount(userId) {
            try {
                const snapshot = await database.ref('routes').orderByChild('createdBy').equalTo(userId).once('value');
                let count = 0;
                snapshot.forEach(() => count++);
                return count;
            } catch (error) {
                console.error('Error counting routes:', error);
                return 0;
            }
        }
        
        // Helper function to get TOTAL content count (routes + swarms + events)
        async function getUserTotalContentCount(userId) {
            try {
                const [routes, swarms, events] = await Promise.all([
                    database.ref('routes').orderByChild('createdBy').equalTo(userId).once('value'),
                    database.ref('swarms').orderByChild('createdBy').equalTo(userId).once('value'),
                    database.ref('events').orderByChild('createdBy').equalTo(userId).once('value')
                ]);
                
                let totalCount = 0;
                routes.forEach(() => totalCount++);
                swarms.forEach(() => totalCount++);
                events.forEach(() => totalCount++);
                
                return totalCount;
            } catch (error) {
                console.error('Error counting total content:', error);
                return 0;
            }
        }
        
        // Filter routes by creator
        function viewUserRoutes(userId, username) {
            let foundRoutes = 0;
            
            // First, reset all routes to default state (collapse any expanded route)
            allRoutesData.forEach(r => {
                r.polyline.setStyle({ opacity: 0.3, weight: 3 });
                // Hide plain pin
                if (r.plainPin && searchMap.hasLayer(r.plainPin)) {
                    searchMap.removeLayer(r.plainPin);
                }
                // Hide numbered markers
                r.markers.forEach(m => {
                    if (searchMap.hasLayer(m)) {
                        searchMap.removeLayer(m);
                    }
                });
            });
            
            // Close info panel if open
            const infoPanel = document.getElementById('searchInfoPanel');
            if (infoPanel) {
                infoPanel.style.display = 'none';
            }
            
            // Now show only routes by this user
            allRoutesData.forEach(routeData => {
                if (routeData.route.createdBy === userId) {
                    // Show this route
                    if (!searchMap.hasLayer(routeData.polyline)) {
                        routeData.polyline.addTo(searchMap);
                    }
                    if (!searchMap.hasLayer(routeData.plainPin)) {
                        routeData.plainPin.addTo(searchMap);
                    }
                    routeData.polyline.setStyle({ opacity: 0.7, weight: 4 });
                    foundRoutes++;
                } else {
                    // Hide this route
                    if (searchMap.hasLayer(routeData.polyline)) {
                        searchMap.removeLayer(routeData.polyline);
                    }
                    if (routeData.plainPin && searchMap.hasLayer(routeData.plainPin)) {
                        searchMap.removeLayer(routeData.plainPin);
                    }
                }
            });
            
            if (foundRoutes > 0) {
                showToast(`Showing ${foundRoutes} routes by ${username}`);
            } else {
                showToast(`No routes found by ${username}`);
            }
        }
        window.viewUserRoutes = viewUserRoutes;
        
        // View user profile with all their content
        async function viewUserProfile(userId, username) {
            // Create fullscreen modal
            const modal = document.createElement('div');
            modal.id = 'user-profile-modal';
            modal.style.cssText = 'position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.95); display: flex; align-items: center; justify-content: center; overflow-y: auto;';
            
            const content = document.createElement('div');
            content.style.cssText = 'background: rgba(25, 25, 25, 0.98); border-radius: 20px; padding: 2rem; max-width: 900px; width: 90%; max-height: 90vh; overflow-y: auto; border: 2px solid rgba(107, 155, 158, 0.3); margin: 2rem;';
            
            content.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem; padding-bottom: 1rem; border-bottom: 2px solid rgba(107, 155, 158, 0.3);">
                    <h2 style="color: var(--accent-color); margin: 0;">üë§ ${username}'s Profile</h2>
                    <button onclick="document.getElementById('user-profile-modal').remove()" style="background: rgba(255, 255, 255, 0.1); border: none; color: var(--accent-light); width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 1.5rem;">‚úï</button>
                </div>
                <div id="profile-loading" style="text-align: center; color: #999; padding: 2rem;">
                    <p>Loading ${username}'s content...</p>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Load all content
            try {
                const [routesSnap, swarmsSnap, eventsSnap] = await Promise.all([
                    database.ref('routes').orderByChild('createdBy').equalTo(userId).once('value'),
                    database.ref('swarms').orderByChild('createdBy').equalTo(userId).once('value'),
                    database.ref('events').orderByChild('createdBy').equalTo(userId).once('value')
                ]);
                
                const routes = [];
                const swarms = [];
                const events = [];
                
                routesSnap.forEach(snap => {
                    routes.push({ id: snap.key, ...snap.val(), type: 'route' });
                });
                
                swarmsSnap.forEach(snap => {
                    swarms.push({ id: snap.key, ...snap.val(), type: 'swarm' });
                });
                
                eventsSnap.forEach(snap => {
                    events.push({ id: snap.key, ...snap.val(), type: 'event' });
                });
                
                const allContent = [...routes, ...swarms, ...events].sort((a, b) => 
                    new Date(b.created) - new Date(a.created)
                );
                
                const totalCount = allContent.length;
                
                let html = `
                    <div style="margin-bottom: 2rem;">
                        <div style="display: flex; gap: 2rem; margin-bottom: 1rem;">
                            <div style="text-align: center;">
                                <div style="font-size: 2rem; color: var(--accent-color); font-weight: bold;">${routes.length}</div>
                                <div style="color: #999; font-size: 0.85rem;">Routes</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 2rem; color: var(--accent-color); font-weight: bold;">${swarms.length}</div>
                                <div style="color: #999; font-size: 0.85rem;">Swarms</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 2rem; color: var(--accent-color); font-weight: bold;">${events.length}</div>
                                <div style="color: #999; font-size: 0.85rem;">Events</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="font-size: 2rem; color: var(--accent-light); font-weight: bold;">${totalCount}</div>
                                <div style="color: #999; font-size: 0.85rem;">Total Posts</div>
                            </div>
                        </div>
                    </div>
                `;
                
                if (totalCount === 0) {
                    html += `<p style="text-align: center; color: #999; padding: 2rem;">No content posted yet.</p>`;
                } else {
                    html += `<div style="display: flex; flex-direction: column; gap: 1rem;">`;
                    
                    allContent.forEach(item => {
                        const emoji = item.type === 'route' ? 'üö∂' : item.type === 'swarm' ? 'üõçÔ∏è' : 'üéâ';
                        const typeLabel = item.type === 'route' ? 'Route' : item.type === 'swarm' ? 'Swarm' : 'Event';
                        const title = item.name || item.title;
                        const desc = item.description || 'No description';
                        const date = new Date(item.created).toLocaleDateString();
                        const sectionMap = { 'route': 'search', 'swarm': 'swarms', 'event': 'events' };
                        
                        // Add recurring badge for events
                        const recurringBadge = ''; // Recurring removed per user request
                        
                        // Add event-specific date/time if it's an event
                        const eventDateTime = item.type === 'event' && item.startDate ? 
                            `<p style="color: var(--accent-light); font-size: 0.85rem; margin: 0.5rem 0; font-weight: 600;">üìÖ ${item.startDate} at ${item.startTime || 'TBD'}</p>` : '';
                        
                        html += `
                            <div onclick="document.getElementById('user-profile-modal').remove(); toggleSection('${sectionMap[item.type]}', '${item.id}')" 
                                 style="background: rgba(30, 30, 30, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; padding: 1.5rem; cursor: pointer; transition: all 0.3s;"
                                 onmouseover="this.style.borderColor='var(--accent-color)'; this.style.transform='translateY(-2px)'"
                                 onmouseout="this.style.borderColor='rgba(107, 155, 158, 0.3)'; this.style.transform='translateY(0)'">
                                <div style="display: flex; align-items: start; gap: 1rem;">
                                    <div style="font-size: 2rem; line-height: 1;">${emoji}</div>
                                    <div style="flex: 1;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                            <h3 style="color: var(--accent-light); margin: 0; font-size: 1.1rem;">${title}${recurringBadge}</h3>
                                            <span style="background: rgba(107, 155, 158, 0.2); color: var(--accent-light); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.75rem; font-weight: 600;">${typeLabel}</span>
                                        </div>
                                        ${eventDateTime}
                                        ${item.recurrenceInfo ? `<p style="color: #999; font-size: 0.8rem; font-style: italic; margin: 0.5rem 0;">${item.recurrenceInfo}</p>` : ''}
                                        <p style="color: #d4d4d4; font-size: 0.9rem; margin: 0.5rem 0; line-height: 1.4;">${desc.substring(0, 150)}${desc.length > 150 ? '...' : ''}</p>
                                        <p style="color: #999; font-size: 0.8rem; margin: 0.5rem 0 0 0;">üìÖ Posted ${date}</p>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `</div>`;
                }
                
                document.getElementById('profile-loading').outerHTML = html;
                
            } catch (error) {
                console.error('Error loading user profile:', error);
                document.getElementById('profile-loading').innerHTML = `
                    <p style="color: #d9534f;">Error loading profile</p>
                `;
            }
        }
        window.viewUserProfile = viewUserProfile;
        
        // Helper function to count user's total swarms
        async function getUserSwarmCount(userId) {
            try {
                const snapshot = await database.ref('swarms').orderByChild('createdBy').equalTo(userId).once('value');
                let count = 0;
                snapshot.forEach(() => count++);
                return count;
            } catch (error) {
                console.error('Error counting swarms:', error);
                return 0;
            }
        }
        
        // Helper function to count user's total events
        async function getUserEventCount(userId) {
            try {
                const snapshot = await database.ref('events').orderByChild('createdBy').equalTo(userId).once('value');
                let count = 0;
                snapshot.forEach(() => count++);
                return count;
            } catch (error) {
                console.error('Error counting events:', error);
                return 0;
            }
        }
        
        // Interest Button Handler
        async function toggleInterest(type, id) {
            // Check if user is signed in AND verified
            if (!checkAuthAndVerification()) {
                return;
            }
            
            const user = auth.currentUser;
            const userId = user.uid;
            
            try {
                if (!window.database) {
                    throw new Error('Firebase database not initialized');
                }
                
                // Check if user already marked interest in Firebase (not localStorage)
                const userInterestRef = window.database.ref(`userInterests/${userId}/${type}/${id}`);
                const interestSnapshot = await userInterestRef.once('value');
                
                if (interestSnapshot.exists()) {
                    showToast('You already marked interest in this!');
                    return;
                }
                
                // Get current count and increment
                const itemRef = window.database.ref(`${type}/${id}/interested`);
                const snapshot = await itemRef.once('value');
                const currentCount = snapshot.val() || 0;
                const newCount = currentCount + 1;
                
                // Update Firebase item count
                await itemRef.set(newCount);
                
                // Save user's interest in Firebase (per user)
                await userInterestRef.set(true);
                
                // Update displayed count
                const countElement = document.getElementById(`${type.slice(0, -1)}-interest-count-${id}`);
                if (countElement) {
                    countElement.textContent = `üë• ${newCount} fl√¢neurs interested`;
                }
                
                // Update button
                const btnElement = document.getElementById(`${type.slice(0, -1)}-interest-btn-${id}`);
                if (btnElement) {
                    btnElement.textContent = '‚úì Interested';
                    btnElement.style.background = 'rgba(107, 155, 158, 0.5)';
                    btnElement.style.cursor = 'default';
                    btnElement.disabled = true;
                }
                
                showToast('Thanks for your interest!');
            } catch (error) {
                console.error('Error updating interest:', error);
                showToast('Error updating interest');
            }
        }
        window.toggleInterest = toggleInterest;
        
        // Like Button Handler (for routes)
        async function toggleLike(type, id) {
            // Check if user is signed in AND verified
            if (!checkAuthAndVerification()) {
                return;
            }
            
            const user = auth.currentUser;
            const userId = user.uid;
            
            try {
                if (!window.database) {
                    throw new Error('Firebase database not initialized');
                }
                
                // Check if user already liked in Firebase (not localStorage)
                const userLikeRef = window.database.ref(`userLikes/${userId}/${type}/${id}`);
                const likeSnapshot = await userLikeRef.once('value');
                
                if (likeSnapshot.exists()) {
                    showToast('You already liked this route!');
                    return;
                }
                
                // Get current count and increment
                const itemRef = window.database.ref(`${type}/${id}/likes`);
                const snapshot = await itemRef.once('value');
                const currentCount = snapshot.val() || 0;
                const newCount = currentCount + 1;
                
                // Update Firebase item count
                await itemRef.set(newCount);
                
                // Save user's like in Firebase (per user)
                await userLikeRef.set(true);
                
                // Update displayed count
                const countElement = document.getElementById(`${type.slice(0, -1)}-like-count-${id}`);
                if (countElement) {
                    countElement.textContent = `‚ù§Ô∏è ${newCount} fl√¢neurs like this route`;
                }
                
                // Update button
                const btnElement = document.getElementById(`${type.slice(0, -1)}-like-btn-${id}`);
                if (btnElement) {
                    btnElement.textContent = '‚ù§Ô∏è Liked';
                    btnElement.style.background = 'rgba(107, 155, 158, 0.5)';
                    btnElement.style.cursor = 'default';
                    btnElement.disabled = true;
                }
                
                showToast('Route liked! Thanks for exploring! ‚ù§Ô∏è');
            } catch (error) {
                console.error('Error updating likes:', error);
                showToast('Error updating likes');
            }
        }
        window.toggleLike = toggleLike;
        
        // Close Route Info Panel and Reset Map View
        function closeRouteInfo() {
            // Hide info panel
            const infoPanel = document.getElementById('searchInfoPanel');
            if (infoPanel) {
                infoPanel.style.display = 'none';
            }
            
            // Reset all routes to initial state and ensure they're all visible
            allRoutesData.forEach(r => {
                // Add polyline back to map if not present
                if (!searchMap.hasLayer(r.polyline)) {
                    r.polyline.addTo(searchMap);
                }
                
                // Reset polyline style
                r.polyline.setStyle({ opacity: 0.7, weight: 4, color: '#8DBCC0' });
                
                // Hide all numbered markers
                r.markers.forEach(marker => {
                    if (searchMap.hasLayer(marker)) {
                        searchMap.removeLayer(marker);
                    }
                });
                
                // Show plain pin
                if (r.plainPin && !searchMap.hasLayer(r.plainPin)) {
                    r.plainPin.addTo(searchMap);
                }
                if (r.plainPin) {
                    r.plainPin.setOpacity(1);
                }
            });
            
            // Zoom out to city level (zoom 12) instead of fitting bounds
            if (allRoutesData.length > 0) {
                // Use first route's coordinates to center, or default to Denver
                const centerCoords = allRoutesData[0]?.route?.waypoints?.[0] || [39.7392, -104.9903];
                searchMap.setView(centerCoords, 12);
            }
            
            selectedRoute = null;
        }
        window.closeRouteInfo = closeRouteInfo;
        
        // Close Swarm Info Panel  
        function closeSwarmInfo() {
            const infoPanel = document.getElementById('swarmInfoPanel');
            if (infoPanel) {
                infoPanel.style.display = 'none';
            }
            
            // Zoom out to city level (zoom 12) like Journey does
            if (window.allSwarmMarkersArray && window.allSwarmMarkersArray.length > 0 && swarmMap) {
                // Use first swarm's coordinates to center, or default to Denver
                const firstMarker = window.allSwarmMarkersArray[0];
                const centerCoords = firstMarker ? firstMarker.getLatLng() : [39.7392, -104.9903];
                swarmMap.setView(centerCoords, 12);
            }
        }
        window.closeSwarmInfo = closeSwarmInfo;
        
        // Close Event Info Panel
        function closeEventInfo() {
            const infoPanel = document.getElementById('eventInfoPanel');
            if (infoPanel) {
                infoPanel.style.display = 'none';
            }
            
            // Zoom out to city level (zoom 12) like Journey does
            if (window.allEventMarkersArray && window.allEventMarkersArray.length > 0 && eventMap) {
                // Use first event's coordinates to center, or default to Denver
                const firstMarker = window.allEventMarkersArray[0];
                const centerCoords = firstMarker ? firstMarker.getLatLng() : [39.7392, -104.9903];
                eventMap.setView(centerCoords, 12);
            }
        }
        window.closeEventInfo = closeEventInfo;
        
        // Toast Notification
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = 'position: fixed; bottom: 2rem; right: 2rem; background: rgba(107, 155, 158, 0.95); color: white; padding: 1rem 2rem; border-radius: 10px; box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3); z-index: 3000;';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }
        window.showToast = showToast;
        
        // ===== REVERSE GEOCODING =====
        // Convert coordinates back to address
        async function reverseGeocode(lat, lng) {
            try {
                const accessToken = 'pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3cifQ.EPETOMFI41QInYccb4Cehg';
                const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?access_token=${accessToken}&limit=1`;
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.features && data.features.length > 0) {
                    const address = data.features[0].place_name;
                    return address;
                }
                return null;
            } catch (error) {
                console.error('Reverse geocoding error:', error);
                return null;
            }
        }
        
        // ===== MAP-PIN MODALS FOR CREATING SWARMS/EVENTS =====
        let pinCreationMap = null;
        let pinCreationMarker = null;
        let selectedPinLocation = null;
        
        function openMapPinSwarm() {
            // Create fullscreen map modal for pin selection
            const modal = document.createElement('div');
            modal.id = 'pinSelectionModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 10000; display: flex; flex-direction: column;';
            
            modal.innerHTML = `
                <div style="padding: 2rem; text-align: center; background: rgba(20, 20, 20, 0.98); position: relative;">
                    <h2 style="color: var(--accent-color); margin: 0 0 1rem 0;">üìç Click the Map to Pin Your Swarm Location</h2>
                    <div style="max-width: 600px; margin: 0 auto;">
                        <input type="text" id="pinMapSearch" placeholder="Search address to zoom to location..." style="width: 100%; padding: 1rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-size: 1rem; font-family: 'Poppins', sans-serif;">
                        <p style="color: #999; font-size: 0.85rem; margin-top: 0.5rem;">üí° Type an address to zoom to that area, then click the map to pin your exact location</p>
                    </div>
                    <button onclick="closePinSelection()" style="position: absolute; top: 1.5rem; right: 1.5rem; background: rgba(200, 50, 50, 0.8); color: white; border: none; padding: 0.5rem 1rem; border-radius: 10px; cursor: pointer; font-weight: 600;">Cancel</button>
                </div>
                <div id="pinCreationMap" style="flex: 1;"></div>
            `;
            
            document.body.appendChild(modal);
            
            // Initialize map - EXACT SAME as Share Your Journey
            setTimeout(() => {
                pinCreationMap = L.map('pinCreationMap').setView([39.7392, -104.9903], 11);
                L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3cifQ.EPETOMFI41QInYccb4Cehg', {
                    tileSize: 512,
                    zoomOffset: -1
                }).addTo(pinCreationMap);
                L.control.attribution({ position: 'bottomright', prefix: false }).addAttribution('¬© <a href="https://www.mapbox.com/">Mapbox</a>').addTo(pinCreationMap);
                
                // CRITICAL: Modal needs invalidateSize after it renders
                setTimeout(() => {
                    pinCreationMap.invalidateSize();
                }, 1000);
                
                // Address search functionality
                let searchTimeout;
                document.getElementById('pinMapSearch').addEventListener('input', function(e) {
                    const query = e.target.value.trim();
                    clearTimeout(searchTimeout);
                    
                    if (query.length < 3) return;
                    
                    searchTimeout = setTimeout(async () => {
                        const coordinates = await geocodeAddress(query);
                        if (coordinates) {
                            pinCreationMap.setView([coordinates.lat, coordinates.lng], 15);
                            showToast('Zoomed to location. Click the map to pin your exact spot!');
                        }
                    }, 500);
                });
                
                // Click to place pin (locked after first placement)
                let pinPlaced = false;
                pinCreationMap.on('click', async function(e) {
                    // Prevent moving pin after its been placed
                    if (pinPlaced) {
                        showToast('Pin already placed. Click Confirm to continue or Cancel to start over.');
                        return;
                    }
                    
                    // Remove existing marker (shouldn't happen but just in case)
                    if (pinCreationMarker) {
                        pinCreationMap.removeLayer(pinCreationMarker);
                    }
                    
                    // Place new marker
                    pinCreationMarker = L.marker([e.latlng.lat, e.latlng.lng]).addTo(pinCreationMap);
                    selectedPinLocation = { lat: e.latlng.lat, lng: e.latlng.lng };
                    pinPlaced = true;  // Lock the pin
                    
                    // Show loading toast
                    showToast('Getting address...');
                    
                    // Reverse geocode to get address
                    const address = await reverseGeocode(e.latlng.lat, e.latlng.lng);
                    
                    if (address) {
                        selectedPinLocation.address = address;
                        pinCreationMarker.bindPopup(`<strong>Selected Location:</strong><br>${address}<br><button onclick="confirmPinSwarm()" style="margin-top: 0.5rem; padding: 0.5rem 1rem; background: var(--accent-color); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">‚úì Confirm & Continue</button>`).openPopup();
                    } else {
                        showToast('Could not get address. Please try another location.');
                        pinPlaced = false;  // Allow trying again if address lookup fails
                    }
                });
            }, 500);
        }
        window.openMapPinSwarm = openMapPinSwarm;
        
        function openMapPinEvent() {
            // Create fullscreen map modal for pin selection
            const modal = document.createElement('div');
            modal.id = 'pinSelectionModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.95); z-index: 10000; display: flex; flex-direction: column;';
            
            modal.innerHTML = `
                <div style="padding: 2rem; text-align: center; background: rgba(20, 20, 20, 0.98); position: relative;">
                    <h2 style="color: var(--accent-color); margin: 0 0 1rem 0;">üìç Click the Map to Pin Your Event Location</h2>
                    <div style="max-width: 600px; margin: 0 auto;">
                        <input type="text" id="pinMapSearch" placeholder="Search address to zoom to location..." style="width: 100%; padding: 1rem; border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 15px; background: rgba(40, 40, 40, 0.9); color: #e0e0e0; font-size: 1rem; font-family: 'Poppins', sans-serif;">
                        <p style="color: #999; font-size: 0.85rem; margin-top: 0.5rem;">üí° Type an address to zoom to that area, then click the map to pin your exact location</p>
                    </div>
                    <button onclick="closePinSelection()" style="position: absolute; top: 1.5rem; right: 1.5rem; background: rgba(200, 50, 50, 0.8); color: white; border: none; padding: 0.5rem 1rem; border-radius: 10px; cursor: pointer; font-weight: 600;">Cancel</button>
                </div>
                <div id="pinCreationMap" style="flex: 1;"></div>
            `;
            
            document.body.appendChild(modal);
            
            // Initialize map - EXACT SAME as Share Your Journey
            setTimeout(() => {
                pinCreationMap = L.map('pinCreationMap').setView([39.7392, -104.9903], 11);
                L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/streets-v11/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoiaGlnaGRlZnBhbnRzIiwiYSI6ImNtaHpiNGt0NzBsNTIyam9saW45YmQ0Z3cifQ.EPETOMFI41QInYccb4Cehg', {
                    tileSize: 512,
                    zoomOffset: -1
                }).addTo(pinCreationMap);
                L.control.attribution({ position: 'bottomright', prefix: false }).addAttribution('¬© <a href="https://www.mapbox.com/">Mapbox</a>').addTo(pinCreationMap);
                
                // CRITICAL: Modal needs invalidateSize after it renders
                setTimeout(() => {
                    pinCreationMap.invalidateSize();
                }, 1000);
                
                // Address search functionality
                let searchTimeout;
                document.getElementById('pinMapSearch').addEventListener('input', function(e) {
                    const query = e.target.value.trim();
                    clearTimeout(searchTimeout);
                    
                    if (query.length < 3) return;
                    
                    searchTimeout = setTimeout(async () => {
                        const coordinates = await geocodeAddress(query);
                        if (coordinates) {
                            pinCreationMap.setView([coordinates.lat, coordinates.lng], 15);
                            showToast('Zoomed to location. Click the map to pin your exact spot!');
                        }
                    }, 500);
                });
                
                // Click to place pin (locked after first placement)
                let pinPlaced = false;
                pinCreationMap.on('click', async function(e) {
                    // Prevent moving pin after its been placed
                    if (pinPlaced) {
                        showToast('Pin already placed. Click Confirm to continue or Cancel to start over.');
                        return;
                    }
                    
                    // Remove existing marker (shouldn't happen but just in case)
                    if (pinCreationMarker) {
                        pinCreationMap.removeLayer(pinCreationMarker);
                    }
                    
                    // Place new marker
                    pinCreationMarker = L.marker([e.latlng.lat, e.latlng.lng]).addTo(pinCreationMap);
                    selectedPinLocation = { lat: e.latlng.lat, lng: e.latlng.lng };
                    pinPlaced = true;  // Lock the pin
                    
                    // Show loading toast
                    showToast('Getting address...');
                    
                    // Reverse geocode to get address
                    const address = await reverseGeocode(e.latlng.lat, e.latlng.lng);
                    
                    if (address) {
                        selectedPinLocation.address = address;
                        pinCreationMarker.bindPopup(`<strong>Selected Location:</strong><br>${address}<br><button onclick="confirmPinEvent()" style="margin-top: 0.5rem; padding: 0.5rem 1rem; background: var(--accent-color); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">‚úì Confirm & Continue</button>`).openPopup();
                    } else {
                        showToast('Could not get address. Please try another location.');
                        pinPlaced = false;  // Allow trying again if address lookup fails
                    }
                });
            }, 500);
        }
        window.openMapPinEvent = openMapPinEvent;
        
        function closePinSelection() {
            const modal = document.getElementById('pinSelectionModal');
            if (modal) modal.remove();
            if (pinCreationMap) {
                pinCreationMap.remove();
                pinCreationMap = null;
            }
            pinCreationMarker = null;
            selectedPinLocation = null;
        }
        window.closePinSelection = closePinSelection;
        
        function confirmPinSwarm() {
            if (!selectedPinLocation) {
                showToast('Please select a location first!');
                return;
            }
            closePinSelection();
            openCreateSwarmModalWithLocation(selectedPinLocation);
        }
        window.confirmPinSwarm = confirmPinSwarm;
        
        function confirmPinEvent() {
            if (!selectedPinLocation) {
                showToast('Please select a location first!');
                return;
            }
            closePinSelection();
            openCreateEventModalWithLocation(selectedPinLocation);
        }
        window.confirmPinEvent = confirmPinEvent;

        // Multi-Business Swarm Functions
        function addSwarmMarker(latlng) {
            // Check if multi-business mode is enabled
            if (!window.swarmMultiBusinessMode && window.swarmMarkers.length >= 1) {
                showToast('Click "Add another location" to add more businesses');
                return;
            }
            
            const markerNumber = window.swarmMarkers.length + 1;
            
            // Create numbered marker for multi-business
            const markerIcon = window.swarmMarkers.length === 0 ? 
                L.divIcon({
                    className: 'swarm-marker-first',
                    html: '<div style="background: #0056b3; color: white; border-radius: 50% 50% 50% 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; transform: rotate(-45deg); box-shadow: 0 2px 8px rgba(0,0,0,0.3);"><span style="transform: rotate(45deg);">' + markerNumber + '</span></div>',
                    iconSize: [32, 32],
                    iconAnchor: [16, 32]
                }) :
                L.divIcon({
                    className: 'swarm-marker',
                    html: '<div style="background: #0056b3; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">' + markerNumber + '</div>',
                    iconSize: [32, 32],
                    iconAnchor: [16, 16]
                });
            
            const marker = L.marker([latlng.lat, latlng.lng], { icon: markerIcon }).addTo(journeyMap);
            window.swarmMarkers.push(marker);
            
            // Initialize business labels array if needed
            if (!window.swarmBusinessLabels) {
                window.swarmBusinessLabels = [];
            }
            window.swarmBusinessLabels.push(''); // Initialize empty label
            
            // Add label input field
            addSwarmLabelInput(markerNumber, latlng);
            
            // Store location with reverse geocoding for address
            reverseGeocode(latlng.lat, latlng.lng).then(address => {
                window.swarmLocations.push({ 
                    lat: latlng.lat, 
                    lng: latlng.lng,
                    address: address
                });
                
                // Auto-fill business name from geocoding
                const labelInput = document.getElementById(`swarmBusinessLabel${markerNumber}`);
                if (labelInput && address) {
                    const businessName = address.split(',')[0].trim();
                    labelInput.value = businessName;
                    window.swarmBusinessLabels[markerNumber - 1] = businessName;
                }
            });
            
            // Update business count display
            updateBusinessCount();
            
            // Enable the Save Swarm button
            const saveBtn = document.getElementById('saveSwarmMapBtn');
            if (saveBtn) saveBtn.disabled = false;
            
            const message = markerNumber === 1 ? 
                'Location pinned! Label the business below.' :
                `Location ${markerNumber} added!`;
            showToast(message);
        }
        window.addSwarmMarker = addSwarmMarker;
        
        function addAnotherBusiness() {
            window.swarmMultiBusinessMode = true;
            showToast('Multi-business mode enabled! Click the map to add more locations.');
        }
        window.addAnotherBusiness = addAnotherBusiness;
        
        function addSwarmLabelInput(markerNumber, latlng) {
            const labelsContainer = document.getElementById('swarmBusinessLabelsContainer');
            const labelsList = document.getElementById('swarmBusinessLabelsList');
            
            if (labelsContainer && labelsList) {
                labelsContainer.style.display = 'block';
                
                const labelInput = document.createElement('div');
                labelInput.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
                labelInput.innerHTML = `
                    <span style="color: var(--accent-light); font-weight: 600; min-width: 30px;">${markerNumber}.</span>
                    <input type="text" 
                           id="swarmBusinessLabel${markerNumber}" 
                           placeholder="Loading business name..."
                           maxlength="50"
                           required
                           style="flex: 1; padding: 0.5rem; background: rgba(40, 40, 40, 0.8); border: 1px solid rgba(107, 155, 158, 0.3); border-radius: 8px; color: white; font-size: 0.9rem;">
                `;
                labelsList.appendChild(labelInput);
                
                // Update swarmBusinessLabels array when input changes
                const input = document.getElementById(`swarmBusinessLabel${markerNumber}`);
                input.addEventListener('input', (e) => {
                    window.swarmBusinessLabels[markerNumber - 1] = e.target.value;
                    // Visual feedback for empty labels
                    if (e.target.value.trim() === '') {
                        e.target.style.borderColor = 'rgba(220, 38, 38, 0.6)';
                    } else {
                        e.target.style.borderColor = 'rgba(107, 155, 158, 0.3)';
                    }
                });
                
                // Initial check if label is empty after timeout (allows auto-fill to work)
                setTimeout(() => {
                    if (!input.value || input.value.trim() === '') {
                        input.style.borderColor = 'rgba(220, 38, 38, 0.6)';
                    }
                }, 500);
            }
        }
        window.addSwarmLabelInput = addSwarmLabelInput;
        
        function updateBusinessCount() {
            const countElement = document.getElementById('businessCount');
            if (countElement && window.swarmLocations) {
                const count = window.swarmLocations.length;
                if (count > 0) {
                    countElement.textContent = `${count} location${count !== 1 ? 's' : ''} pinned`;
                    countElement.style.display = 'block';
                } else {
                    countElement.style.display = 'none';
                }
            }
        }

        // Modal Functions
        function openCreateSwarmModalWithLocation(location) {
            document.getElementById('createSwarmModal').style.display = 'flex';
            // Enable submit button
            document.getElementById('createSwarmBtn').disabled = false;
            // Set minimum date to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('swarmDateInput').setAttribute('min', today);
        }
        
        function openCreateEventModalWithLocation(location) {
            document.getElementById('createEventModal').style.display = 'flex';
            // Enable submit button
            document.getElementById('createEventBtn').disabled = false;
            // Set minimum dates to today
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('eventStartDateInput').setAttribute('min', today);
            document.getElementById('eventEndDateInput').setAttribute('min', today);
        }
        
        function openCreateSwarmModal() {
            // Check if locations have been pinned
            if (!window.swarmLocations || window.swarmLocations.length === 0) {
                showToast('Please pin at least one location on the map first!');
                return;
            }
            
            // Validate that all businesses have labels BEFORE opening modal
            if (!window.swarmBusinessLabels || window.swarmBusinessLabels.length !== window.swarmLocations.length) {
                showToast('Please label all businesses before saving!');
                return;
            }
            
            const emptyLabels = window.swarmBusinessLabels.filter((label, idx) => !label || label.trim() === '');
            if (emptyLabels.length > 0) {
                showToast('Please label all businesses before saving!');
                return;
            }
            
            // Use first location for the modal (primary meeting point)
            openCreateSwarmModalWithLocation(window.swarmLocations[0]);
        }

        function closeCreateSwarmModal() {
            document.getElementById('createSwarmModal').style.display = 'none';
            document.getElementById('createSwarmForm').reset();
            // Disable button again
            document.getElementById('createSwarmBtn').disabled = true;
            // Clear all markers and locations
            if (window.swarmMarkers && journeyMap) {
                window.swarmMarkers.forEach(marker => {
                    journeyMap.removeLayer(marker);
                });
                window.swarmMarkers = [];
            }
            if (window.swarmLocations) {
                window.swarmLocations = [];
            }
            if (window.swarmBusinessLabels) {
                window.swarmBusinessLabels = [];
            }
            // Reset multi-business mode
            window.swarmMultiBusinessMode = false;
            // Clear and hide labels container
            const labelsContainer = document.getElementById('swarmBusinessLabelsContainer');
            const labelsList = document.getElementById('swarmBusinessLabelsList');
            if (labelsContainer) labelsContainer.style.display = 'none';
            if (labelsList) labelsList.innerHTML = '';
            updateBusinessCount();
        }

        function openCreateEventModal() {
            // Check if location has been pinned
            if (!window.eventLocation || !window.eventLocation.lat || !window.eventLocation.lng) {
                showToast('Please pin a location on the map first!');
                return;
            }
            
            // Reverse geocode to get address
            reverseGeocode(window.eventLocation.lat, window.eventLocation.lng).then(address => {
                openCreateEventModalWithLocation({
                    lat: window.eventLocation.lat,
                    lng: window.eventLocation.lng,
                    address: address
                });
            });
        }

        function closeCreateEventModal() {
            const modal = document.getElementById('createEventModal');
            const form = document.getElementById('createEventForm');
            const customField = document.getElementById('customEventTypeField');
            const btn = document.getElementById('createEventBtn');
            
            if (modal) modal.style.display = 'none';
            if (form) form.reset();
            if (customField) customField.style.display = 'none';
            if (btn) btn.disabled = true;
            
            // Clear window location
            window.eventLocation = null;
            if (window.eventMarker && journeyMap) {
                journeyMap.removeLayer(window.eventMarker);
                window.eventMarker = null;
            }
        }
        
        
        function toggleCustomRouteCategory() {
            const select = document.getElementById('routeCategory');
            const customField = document.getElementById('customRouteCategoryField');
            const customInput = document.getElementById('customRouteCategory');
            
            if (select.value === 'Other') {
                customField.style.display = 'block';
                customInput.required = true;
            } else {
                customField.style.display = 'none';
                customInput.required = false;
                customInput.value = '';
            }
        }
        
        // Make modal functions globally accessible
        window.openCreateSwarmModal = openCreateSwarmModal;
        window.closeCreateSwarmModal = closeCreateSwarmModal;
        window.openCreateEventModal = openCreateEventModal;
        window.closeCreateEventModal = closeCreateEventModal;
        window.toggleCustomRouteCategory = toggleCustomRouteCategory;

        // Submit handlers
        async function submitSwarm(event) {
            event.preventDefault();
            
            // Check if user is banned
            const isBanned = await checkIfBanned();
            if (isBanned) {
                showToast('Your account has been suspended. Contact support for assistance.');
                return;
            }
            
            const formData = new FormData(event.target);
            
            // Get coordinates from the pins (first one is primary meeting point)
            if (!window.swarmLocations || window.swarmLocations.length === 0) {
                showToast('Please place at least one pin on the map to set the location.');
                return;
            }
            
            // Validate that all businesses have labels
            if (!window.swarmBusinessLabels || window.swarmBusinessLabels.length !== window.swarmLocations.length) {
                showToast('Please label all businesses before saving!');
                return;
            }
            
            const emptyLabels = window.swarmBusinessLabels.filter((label, idx) => !label || label.trim() === '');
            if (emptyLabels.length > 0) {
                showToast('Please label all businesses before saving!');
                return;
            }
            
            const primaryLocation = window.swarmLocations[0];
            const user = auth.currentUser;
            const displayName = user.displayName || user.email.split('@')[0];
            
            const swarmData = {
                title: formData.get('swarmTitle'),
                meetingLocation: formData.get('swarmMeetingLocation'), // Manual text field
                lat: primaryLocation.lat, // Primary pin
                lng: primaryLocation.lng, // Primary pin
                locations: window.swarmLocations, // All pinned locations
                businessLabels: window.swarmBusinessLabels, // Business names
                locationCount: window.swarmLocations.length,
                date: formData.get('swarmDate'),
                time: formData.get('swarmTime'),
                description: formData.get('swarmDescription'),
                postedBy: formData.get('swarmPostedBy'),
                duration: formData.get('swarmDuration'),
                identifier: formData.get('swarmIdentifier'),
                interested: 0,
                created: new Date().toISOString(),
                createdBy: user.uid,
                createdByName: displayName,
                createdByEmail: user.email
            };
            
            // Save to Firebase (also keeps localStorage as backup)
            if (window.editingSwarmId) {
                // UPDATE existing swarm
                await database.ref(`swarms/${window.editingSwarmId}`).update(swarmData);
                showToast('Swarm updated successfully!');
                window.editingSwarmId = null; // Clear editing flag
                closeCreateSwarmModal();
                openDashboard(); // Show updated swarm in dashboard
            } else {
                // CREATE new swarm
                const newSwarmId = await saveSwarmToFirebase(swarmData);
                
                // Also save to localStorage as backup
                let swarms = JSON.parse(localStorage.getItem('swarms') || '[]');
                swarms.push(swarmData);
                localStorage.setItem('swarms', JSON.stringify(swarms));
                
                const locationText = swarmData.locationCount > 1 ? 
                    `Shopping Swarm with ${swarmData.locationCount} locations created successfully!` :
                    'Shopping Swarm created successfully!';
                showToast(locationText);
                closeCreateSwarmModal();
                
                // Close the creation map and open browse swarms with the new swarm highlighted
                if (newSwarmId) {
                    // Close creation section without triggering scroll
                    const modal = document.getElementById('fullscreen-swarm-map-v2');
                    if (modal) {
                        // Remove modal directly without triggering closeBtn onclick
                        modal.style.display = 'none';
                        modal.remove();
                        document.body.classList.remove('choreography-active');
                        
                        // Remove all map click handlers before nulling
                        if (journeyMap) {
                            journeyMap.off('click');
                        }
                        journeyMap = null;
                    }
                    // Open browse swarms immediately (no delay needed)
                    toggleSection('swarms', newSwarmId);
                }
            }
        }

        async function submitEvent(event) {
            event.preventDefault();
            
            // Check if user is banned
            const isBanned = await checkIfBanned();
            if (isBanned) {
                showToast('Your account has been suspended. Contact support for assistance.');
                return;
            }
            
            const formData = new FormData(event.target);
            
            // Get coordinates from the pin
            const lat = window.eventLocation?.lat;
            const lng = window.eventLocation?.lng;
            
            if (!lat || !lng) {
                showToast('Please place a pin on the map to set the location.');
                return;
            }
            
            const user = auth.currentUser;
            const displayName = user.displayName || user.email.split('@')[0];
            
            const eventData = {
                name: formData.get('eventName'),
                location: formData.get('eventLocation'), // Manual text field
                lat: lat, // From pin
                lng: lng, // From pin
                startDate: formData.get('eventStartDate'),
                startTime: formData.get('eventStartTime'),
                endDate: formData.get('eventEndDate'),
                endTime: formData.get('eventEndTime'),
                description: formData.get('eventDescription'),
                website: formData.get('eventWebsite'),
                maxParticipants: formData.get('eventMaxParticipants'),
                postedBy: formData.get('eventPostedBy'),
                interested: 0,
                created: new Date().toISOString(),
                createdBy: user.uid,
                createdByName: displayName,
                createdByEmail: user.email
            };
            
            // Save to Firebase (also keeps localStorage as backup)
            if (window.editingEventId) {
                // UPDATE existing event
                await database.ref(`events/${window.editingEventId}`).update(eventData);
                showToast('Event updated successfully!');
                window.editingEventId = null; // Clear editing flag
                closeCreateEventModal();
                openDashboard(); // Show updated event in dashboard
            } else {
                // CREATE new event
                const newEventId = await saveEventToFirebase(eventData);
                console.log('EVENT DEBUG: newEventId =', newEventId);
                
                // Also save to localStorage as backup
                let events = JSON.parse(localStorage.getItem('events') || '[]');
                events.push(eventData);
                localStorage.setItem('events', JSON.stringify(events));
                
                showToast('Event created successfully!');
                closeCreateEventModal();
                console.log('EVENT DEBUG: Modal closed, about to check for fullscreen modal');
                
                // Close the creation map and open browse events with the new event highlighted
                if (newEventId) {
                    console.log('EVENT DEBUG: newEventId exists, looking for modal');
                    // Close creation section without triggering scroll
                    const modal = document.getElementById('fullscreen-event-map-v2');
                    console.log('EVENT DEBUG: Found modal?', !!modal, 'Modal:', modal);
                    if (modal) {
                        console.log('EVENT DEBUG: Removing modal');
                        // Remove modal directly without triggering closeBtn onclick
                        modal.style.display = 'none';
                        modal.remove();
                        document.body.classList.remove('choreography-active');
                        
                        // Remove all map click handlers before nulling
                        if (journeyMap) {
                            journeyMap.off('click');
                        }
                        journeyMap = null;
                        console.log('EVENT DEBUG: Modal removed, about to call toggleSection');
                    }
                    // Open browse events immediately (no delay needed)
                    console.log('EVENT DEBUG: Calling toggleSection with events and', newEventId);
                    toggleSection('events', newEventId);
                    console.log('EVENT DEBUG: toggleSection called');
                } else {
                    console.log('EVENT DEBUG: newEventId is null/undefined!');
                }
            }
        }

        // Interest counter
        function addInterest(type, id) {
            // Update the displayed count
            const countElement = document.getElementById(`${type}-interest-${id}`);
            if (countElement) {
                // Extract current count from text
                const currentText = countElement.textContent;
                const currentCount = parseInt(currentText.match(/\d+/)[0]) || 0;
                const newCount = currentCount + 1;
                countElement.textContent = `üë• ${newCount} fl√¢neurs interested`;
                showToast('Thanks for your interest!');
                
                // Update Firebase (if id is a Firebase key, not array index)
                if (typeof id === 'string' && id.includes('-')) {
                    updateInterestCount(type, id, newCount);
                }
                
                // Also save to localStorage if this is a stored item
                const key = type === 'swarm' ? 'swarms' : 'events';
                let items = JSON.parse(localStorage.getItem(key) || '[]');
                if (items[id]) {
                    items[id].interested = newCount;
                    localStorage.setItem(key, JSON.stringify(items));
                }
                
                // Navigate to the map section with highlighted item
                const sectionName = type === 'swarm' ? 'swarms' : 'events';
                setTimeout(() => {
                    toggleSection(sectionName, id);
                }, 500);
            }
        }

        // Share functionality
        function shareItem(title, url) {
            if (navigator.share) {
                navigator.share({
                    title: title,
                    url: url || window.location.href
                }).catch(() => {});
            } else {
                // Fallback: copy to clipboard
                navigator.clipboard.writeText(url || window.location.href);
                showToast('Link copied to clipboard!');
            }
        }
        
        // Make submit and interaction functions globally accessible
        window.submitSwarm = submitSwarm;
        window.submitEvent = submitEvent;
        
        // Toggle recurring event options visibility
        window.addInterest = addInterest;
        window.shareItem = shareItem;

        // Format date display
        function formatDateDisplay(dateStr) {
            const eventDate = new Date(dateStr);
            const now = new Date();
            const currentWeekStart = new Date(now.setDate(now.getDate() - now.getDay()));
            const currentWeekEnd = new Date(currentWeekStart);
            currentWeekEnd.setDate(currentWeekEnd.getDate() + 6);
            
            if (eventDate >= currentWeekStart && eventDate <= currentWeekEnd) {
                // Within current week - show day name
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                return days[eventDate.getDay()];
            } else {
                // Beyond current week - show full date
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                return `${months[eventDate.getMonth()]} ${eventDate.getDate()}`;
            }
        }
        
        // ===== LOAD LISTS IN MODALS =====
        
        // ===== LOAD ROUTES LIST IN SEARCH SECTION =====
        function loadRoutesListInModal(routes) {
            const container = document.getElementById('routes-list-container');
            if (!container) return;
            
            if (routes.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; width: 100%; padding: 2rem;">No routes saved yet. Be the first to share your journey!</p>';
                return;
            }
            
            container.innerHTML = '';
            routes.forEach(route => {
                const card = document.createElement('div');
                card.style.cssText = 'background: rgba(40, 40, 40, 0.8); padding: 1.5rem; border-radius: 15px; cursor: pointer; transition: transform 0.2s;';
                card.innerHTML = `
                    <h4 style="color: var(--accent-color); margin-bottom: 0.5rem;">${route.name}</h4>
                    ${route.description ? `<p style="color: #d4d4d4; margin: 0.5rem 0;">${route.description}</p>` : ''}
                    ${route.category ? `<p style="color: #d4d4d4; margin: 0.5rem 0;">üìÅ ${route.category}</p>` : ''}
                    <p style="color: var(--accent-light); font-weight: 600; margin-top: 0.8rem;">üìç ${route.waypointCount} waypoints</p>
                `;
                card.addEventListener('click', () => {
                    // Find the polyline and highlight it
                    if (searchMap) {
                        const bounds = L.latLngBounds(route.waypoints);
                        searchMap.fitBounds(bounds, { padding: [50, 50] });
                        
                        // Flash the route
                        searchMap.eachLayer(layer => {
                            if (layer instanceof L.Polyline) {
                                const layerBounds = layer.getBounds();
                                if (layerBounds.equals(bounds)) {
                                    layer.setStyle({ color: '#FF6B6B', weight: 6 });
                                    setTimeout(() => {
                                        layer.setStyle({ color: '#8DBCC0', weight: 4 });
                                    }, 1000);
                                    layer.openPopup();
                                }
                            }
                        });
                    }
                });
                card.addEventListener('mouseenter', () => card.style.transform = 'translateY(-4px)');
                card.addEventListener('mouseleave', () => card.style.transform = 'translateY(0)');
                container.appendChild(card);
            });
        }

        // === FINAL SAFETY CHECK - Ensure all functions are globally accessible ===
        if (typeof toggleSection !== 'undefined') window.toggleSection = toggleSection;
        if (typeof showToast !== 'undefined') window.showToast = showToast;
        if (typeof openCreateSwarmModal !== 'undefined') window.openCreateSwarmModal = openCreateSwarmModal;
        if (typeof closeCreateSwarmModal !== 'undefined') window.closeCreateSwarmModal = closeCreateSwarmModal;
        if (typeof openCreateEventModal !== 'undefined') window.openCreateEventModal = openCreateEventModal;
        if (typeof closeCreateEventModal !== 'undefined') window.closeCreateEventModal = closeCreateEventModal;
        if (typeof submitSwarm !== 'undefined') window.submitSwarm = submitSwarm;
        if (typeof submitEvent !== 'undefined') window.submitEvent = submitEvent;
        if (typeof addInterest !== 'undefined') window.addInterest = addInterest;
        if (typeof shareItem !== 'undefined') window.shareItem = shareItem;
        if (typeof clearRoute !== 'undefined') window.clearRoute = clearRoute;
        if (typeof openSaveRouteModal !== 'undefined') window.openSaveRouteModal = openSaveRouteModal;
        if (typeof confirmSaveRoute !== 'undefined') window.confirmSaveRoute = confirmSaveRoute;
        if (typeof toggleCustomEventType !== 'undefined') window.toggleCustomEventType = toggleCustomEventType;
        if (typeof toggleCustomRouteCategory !== 'undefined') window.toggleCustomRouteCategory = toggleCustomRouteCategory;
        
        // === BAN SYSTEM ===
        
        // Check if user is banned
        async function checkIfBanned() {
            const user = auth.currentUser;
            if (!user) return false;
            
            try {
                const banSnapshot = await database.ref(`bannedUsers/${user.uid}`).once('value');
                return banSnapshot.exists();
            } catch (error) {
                console.error('Error checking ban status:', error);
                return false;
            }
        }
        window.checkIfBanned = checkIfBanned;
        
        // Show suspension banner
        function showSuspensionBanner() {
            let banner = document.getElementById('suspension-banner');
            if (!banner) {
                banner = document.createElement('div');
                banner.id = 'suspension-banner';
                banner.style.cssText = 'background: rgba(255, 70, 70, 0.2); border: 2px solid #ff4646; color: #ff4646; padding: 1rem 2rem; text-align: center; font-weight: 600; position: fixed; top: 80px; left: 0; right: 0; z-index: 9999;';
                banner.innerHTML = 'üö´ Your account has been suspended. You can browse but cannot create content or send messages. Contact support for assistance.';
                document.body.appendChild(banner);
            }
            banner.style.display = 'block';
        }
        
        // Hide suspension banner
        function hideSuspensionBanner() {
            const banner = document.getElementById('suspension-banner');
            if (banner) {
                banner.style.display = 'none';
            }
        }
        
        // Disable user actions (hide buttons that create/send content)
        function disableUserActions() {
            // Add CSS to hide action buttons
            let style = document.getElementById('ban-style');
            if (!style) {
                style = document.createElement('style');
                style.id = 'ban-style';
                document.head.appendChild(style);
            }
            style.textContent = `
                button[onclick*="openSaveRouteModal"],
                button[onclick*="openCreateSwarmModal"],
                button[onclick*="openCreateEventModal"],
                button[onclick*="openMessageModal"],
                button[onclick*="replyToMessage"] {
                    display: none !important;
                }
            `;
        }
        
        // Enable user actions (show buttons)
        function enableUserActions() {
            const style = document.getElementById('ban-style');
            if (style) {
                style.remove();
            }
        }
        
        // === MESSAGING SYSTEM ===
        
        // Open message modal
        function openMessageModal(recipientId, recipientName, type, itemName) {
            if (!auth.currentUser) {
                showToast('Please sign in to send messages');
                return;
            }
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'messageModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 10, 10, 0.95); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 2rem;';
            
            // Escape strings for HTML
            const escapedRecipientName = recipientName.replace(/'/g, "\\'").replace(/"/g, "&quot;");
            const escapedItemName = itemName.replace(/'/g, "\\'").replace(/"/g, "&quot;");
            
            modal.innerHTML = `
                <div style="background: rgba(25, 25, 25, 0.98); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 20px; padding: 2rem; max-width: 600px; width: 100%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 style="color: var(--accent-color); margin: 0;">üìß Contact ${escapedRecipientName}</h3>
                        <button onclick="document.getElementById('messageModal').remove()" style="background: none; border: none; color: var(--accent-light); font-size: 1.5rem; cursor: pointer;">&times;</button>
                    </div>
                    
                    <p style="color: #d4d4d4; margin-bottom: 1rem;">About: <strong>${escapedItemName}</strong></p>
                    
                    <form id="messageForm" onsubmit="sendMessage(event, '${recipientId}', '${escapedRecipientName}', '${type}', '${escapedItemName}')">
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Subject *</label>
                            <input type="text" id="messageSubject" required maxlength="100" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="Question about the ${type}">
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Message *</label>
                            <textarea id="messageText" required maxlength="1000" rows="6" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem; resize: vertical;" placeholder="Hi, I'm interested in..."></textarea>
                            <p style="color: #999; font-size: 0.85rem; margin-top: 0.5rem;">üí° Your username will be visible to the organizer. Messages are private and only visible between you and the recipient. Event/swarm messages auto-delete 30 days after the event.</p>
                        </div>
                        
                        <!-- Honeypot field (hidden from humans, bots will fill it) -->
                        <input type="text" id="messageWebsite" name="website" style="position: absolute; left: -9999px; width: 1px; height: 1px;" tabindex="-1" autocomplete="off">
                        
                        <button type="submit" class="feature-btn" style="width: 100%;">Send Message</button>
                    </form>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        window.openMessageModal = openMessageModal;
        
        // Send message
        async function sendMessage(event, recipientId, recipientName, type, itemName) {
            event.preventDefault();
            
            const user = auth.currentUser;
            if (!user) {
                showToast('Please sign in to send messages');
                return;
            }
            
            // Check if user is banned
            const isBanned = await checkIfBanned();
            if (isBanned) {
                showToast('Your account has been suspended. Contact support for assistance.');
                const modal = document.getElementById('messageModal');
                if (modal) modal.remove();
                return;
            }
            
            // ANTI-BOT CHECK 1: Honeypot field
            const honeypot = document.getElementById('messageWebsite').value;
            if (honeypot) {
                console.log('Bot detected: honeypot filled');
                showToast('Error sending message');
                const modal = document.getElementById('messageModal');
                if (modal) modal.remove();
                return; // Bot detected, silently reject
            }
            
            // ANTI-BOT CHECK 2: Rate limiting (max 10 messages per hour from this browser)
            const messageAttempts = JSON.parse(localStorage.getItem('messageAttempts') || '[]');
            const now = Date.now();
            const oneHourAgo = now - (60 * 60 * 1000);
            const recentAttempts = messageAttempts.filter(time => time > oneHourAgo);
            
            if (recentAttempts.length >= 10) {
                showToast('Too many messages sent. Please try again later.');
                const modal = document.getElementById('messageModal');
                if (modal) modal.remove();
                return;
            }
            
            const subject = document.getElementById('messageSubject').value;
            const messageText = document.getElementById('messageText').value;
            
            const messageData = {
                from: user.uid,
                fromName: user.displayName || user.email.split('@')[0],
                fromEmail: user.email,
                to: recipientId,
                toName: recipientName,
                subject: subject,
                message: messageText,
                type: type,
                itemName: itemName,
                timestamp: new Date().toISOString(),
                read: false
            };
            
            try {
                await database.ref('messages').push(messageData);
                
                // Record message attempt for rate limiting
                recentAttempts.push(now);
                localStorage.setItem('messageAttempts', JSON.stringify(recentAttempts));
                
                showToast('Message sent successfully!');
                const modal = document.getElementById('messageModal');
                if (modal) modal.remove();
            } catch (error) {
                console.error('Error sending message:', error);
                if (error.code === 'PERMISSION_DENIED') {
                    showToast('Permission denied. Please make sure you\'re logged in and Firebase rules are configured.');
                } else {
                    showToast('Error sending message: ' + error.message);
                }
                const modal = document.getElementById('messageModal');
                if (modal) modal.remove();
            }
        }
        window.sendMessage = sendMessage;
        
        // Load user's messages (inbox)
        async function loadMessages() {
            const user = auth.currentUser;
            if (!user) return;
            
            try {
                const messagesSnapshot = await database.ref('messages').orderByChild('to').equalTo(user.uid).once('value');
                const messages = [];
                
                messagesSnapshot.forEach(snap => {
                    const msg = snap.val();
                    // Filter out hidden messages (hidden after 30 days but retained for 3 years)
                    if (!msg.hidden) {
                        messages.push({ id: snap.key, ...msg });
                    }
                });
                
                // Sort by newest first
                messages.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                return messages;
            } catch (error) {
                console.error('Error loading messages:', error);
                return [];
            }
        }
        window.loadMessages = loadMessages;
        
        // Clean up old event/swarm messages (7 days after event date)
        async function cleanupOldMessages() {
            try {
                const allMessagesSnapshot = await database.ref('messages').once('value');
                const now = new Date();
                const hidePromises = [];
                const deletePromises = [];
                
                allMessagesSnapshot.forEach(snap => {
                    const msg = snap.val();
                    const messageDate = new Date(msg.timestamp);
                    const daysSinceMessage = (now - messageDate) / (1000 * 60 * 60 * 24);
                    
                    // HIDE messages after 30 days (for privacy - hides from user view)
                    // Only hide event/swarm messages, not direct replies
                    if ((msg.type === 'event' || msg.type === 'swarm') && daysSinceMessage > 30 && !msg.hidden) {
                        console.log('Hiding message from user view:', snap.key);
                        hidePromises.push(database.ref(`messages/${snap.key}`).update({ hidden: true }));
                    }
                    
                    // ACTUALLY DELETE messages after 3 years (1095 days) for legal retention
                    // This applies to ALL message types (event, swarm, reply)
                    if (daysSinceMessage > 1095) {
                        console.log('Permanently deleting message (3 year retention expired):', snap.key);
                        deletePromises.push(database.ref(`messages/${snap.key}`).remove());
                    }
                });
                
                // Execute hide operations
                if (hidePromises.length > 0) {
                    await Promise.all(hidePromises);
                    console.log(`Hidden ${hidePromises.length} messages from user view (30+ days old)`);
                }
                
                // Execute delete operations
                if (deletePromises.length > 0) {
                    await Promise.all(deletePromises);
                    console.log(`Permanently deleted ${deletePromises.length} messages (3+ years old)`);
                }
            } catch (error) {
                console.error('Error cleaning up messages:', error);
            }
        }
        window.cleanupOldMessages = cleanupOldMessages;
        
        // Cleanup deleted routes after 6 months retention
        async function cleanupDeletedRoutes() {
            try {
                const allRoutesSnapshot = await database.ref('routes').once('value');
                const now = new Date();
                const deletePromises = [];
                
                allRoutesSnapshot.forEach(snap => {
                    const route = snap.val();
                    
                    // Only process routes that have been soft-deleted
                    if (route.deleted && route.deletedAt) {
                        const deletedDate = new Date(route.deletedAt);
                        const daysSinceDeletion = (now - deletedDate) / (1000 * 60 * 60 * 24);
                        
                        // PERMANENTLY DELETE routes after 6 months (180 days) retention
                        if (daysSinceDeletion > 180) {
                            console.log('Permanently deleting route (6 month retention expired):', snap.key);
                            deletePromises.push(database.ref(`routes/${snap.key}`).remove());
                        }
                    }
                });
                
                // Execute delete operations
                if (deletePromises.length > 0) {
                    await Promise.all(deletePromises);
                    console.log(`Permanently deleted ${deletePromises.length} routes (6+ months old)`);
                }
            } catch (error) {
                console.error('Error cleaning up deleted routes:', error);
            }
        }
        window.cleanupDeletedRoutes = cleanupDeletedRoutes;
        
        // Get unread message count
        async function getUnreadMessageCount() {
            const user = auth.currentUser;
            if (!user) return 0;
            
            try {
                const messagesSnapshot = await database.ref('messages').orderByChild('to').equalTo(user.uid).once('value');
                let unreadCount = 0;
                
                messagesSnapshot.forEach(snap => {
                    const msg = snap.val();
                    if (!msg.read) unreadCount++;
                });
                
                return unreadCount;
            } catch (error) {
                console.error('Error counting messages:', error);
                return 0;
            }
        }
        window.getUnreadMessageCount = getUnreadMessageCount;
        
        // Mark message as read
        async function markMessageRead(messageId) {
            try {
                await database.ref(`messages/${messageId}`).update({ read: true });
            } catch (error) {
                console.error('Error marking message as read:', error);
            }
        }
        window.markMessageRead = markMessageRead;
        
        // Reply to a message (internal messaging)
        function replyToMessage(recipientId, recipientName, defaultSubject) {
            if (!auth.currentUser) {
                showToast('Please sign in to send messages');
                return;
            }
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'replyModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(10, 10, 10, 0.95); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 2rem;';
            
            modal.innerHTML = `
                <div style="background: rgba(25, 25, 25, 0.98); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 20px; padding: 2rem; max-width: 600px; width: 100%; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                        <h3 style="color: var(--accent-color); margin: 0;">üí¨ Reply to ${recipientName}</h3>
                        <button onclick="document.getElementById('replyModal').remove()" style="background: none; border: none; color: var(--accent-light); font-size: 1.5rem; cursor: pointer;">&times;</button>
                    </div>
                    
                    <form id="replyForm" onsubmit="sendReply(event, '${recipientId}', '${recipientName}')">
                        <div style="margin-bottom: 1rem;">
                            <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Subject *</label>
                            <input type="text" id="replySubject" required maxlength="100" value="${defaultSubject}" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                        </div>
                        
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Message *</label>
                            <textarea id="replyText" required maxlength="1000" rows="6" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem; resize: vertical;" placeholder="Type your reply..."></textarea>
                            <p style="color: #999; font-size: 0.85rem; margin-top: 0.5rem;">üí° Messages are private and only visible to you and the recipient</p>
                        </div>
                        
                        <!-- Honeypot field -->
                        <input type="text" id="replyWebsite" name="website" style="position: absolute; left: -9999px; width: 1px; height: 1px;" tabindex="-1" autocomplete="off">
                        
                        <button type="submit" class="feature-btn" style="width: 100%;">Send Reply</button>
                    </form>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        window.replyToMessage = replyToMessage;
        
        // Send reply
        async function sendReply(event, recipientId, recipientName) {
            event.preventDefault();
            
            const user = auth.currentUser;
            if (!user) {
                showToast('Please sign in to send messages');
                return;
            }
            
            // Check if user is banned
            const isBanned = await checkIfBanned();
            if (isBanned) {
                showToast('Your account has been suspended. Contact support for assistance.');
                const modal = document.getElementById('replyModal');
                if (modal) modal.remove();
                return;
            }
            
            // Honeypot check
            const honeypot = document.getElementById('replyWebsite').value;
            if (honeypot) {
                console.log('Bot detected');
                showToast('Error sending reply');
                const modal = document.getElementById('replyModal');
                if (modal) modal.remove();
                return;
            }
            
            // Rate limiting check (same as sendMessage - 10/hour)
            const messageAttempts = JSON.parse(localStorage.getItem('messageAttempts') || '[]');
            const now = Date.now();
            const oneHourAgo = now - (60 * 60 * 1000);
            const recentAttempts = messageAttempts.filter(time => time > oneHourAgo);
            
            if (recentAttempts.length >= 10) {
                showToast('Too many messages sent. Please try again later.');
                const modal = document.getElementById('replyModal');
                if (modal) modal.remove();
                return;
            }
            
            const subject = document.getElementById('replySubject').value;
            const messageText = document.getElementById('replyText').value;
            
            const messageData = {
                from: user.uid,
                fromName: user.displayName || user.email.split('@')[0],
                fromEmail: user.email,
                to: recipientId,
                toName: recipientName,
                subject: subject,
                message: messageText,
                type: 'reply',
                itemName: 'Message Reply',
                timestamp: new Date().toISOString(),
                read: false
            };
            
            try {
                await database.ref('messages').push(messageData);
                
                // Record attempt
                recentAttempts.push(now);
                localStorage.setItem('messageAttempts', JSON.stringify(recentAttempts));
                
                showToast('Reply sent successfully!');
                const modal = document.getElementById('replyModal');
                if (modal) modal.remove();
            } catch (error) {
                console.error('Error sending reply:', error);
                showToast('Error sending reply');
                const modal = document.getElementById('replyModal');
                if (modal) modal.remove();
            }
        }
        window.sendReply = sendReply;
        
        // Delete message
        async function deleteMessage(messageId) {
            if (!confirm('Delete this message?')) return;
            
            try {
                await database.ref(`messages/${messageId}`).remove();
                showToast('Message deleted');
                openDashboard(); // Refresh dashboard
            } catch (error) {
                console.error('Error deleting message:', error);
                showToast('Error deleting message');
            }
        }
        window.deleteMessage = deleteMessage;
        
        // Report message as spam/abuse
        async function reportMessage(messageId, reportedUserId, subject) {
            if (!confirm('Report this message as spam or abuse? This will be reviewed by site administrators.')) return;
            
            const user = auth.currentUser;
            if (!user) return;
            
            try {
                // Fetch the full message content
                const messageSnapshot = await database.ref(`messages/${messageId}`).once('value');
                const messageData = messageSnapshot.val();
                
                if (!messageData) {
                    showToast('Message not found');
                    return;
                }
                
                // Include full message details in report for easy admin review
                const reportData = {
                    messageId: messageId,
                    reportedBy: user.uid,
                    reportedByEmail: user.email,
                    reportedByName: user.displayName || user.email.split('@')[0],
                    reportedUser: reportedUserId,
                    reportedUserName: messageData.fromName,
                    reportedUserEmail: messageData.fromEmail,
                    messageSubject: subject,
                    messageContent: messageData.message, // Full message text
                    messageType: messageData.type,
                    itemName: messageData.itemName,
                    originalTimestamp: messageData.timestamp,
                    reportTimestamp: new Date().toISOString(),
                    status: 'pending'
                };
                
                await database.ref('reports').push(reportData);
                showToast('Message reported. Thank you for helping keep our community safe.');
            } catch (error) {
                console.error('Error reporting message:', error);
                showToast('Error submitting report');
            }
        }
        window.reportMessage = reportMessage;
        
    </script>

    <!-- Create Swarm Modal -->
    <div id="createSwarmModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; padding: 2rem;">
        <div style="background: rgba(25, 25, 25, 0.98); border-radius: 20px; padding: 2.5rem; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; border: 2px solid rgba(107, 155, 158, 0.3); position: relative;">
            <button onclick="closeCreateSwarmModal()" style="position: absolute; top: 1rem; right: 1rem; background: none; border: none; color: var(--accent-color); font-size: 2rem; cursor: pointer; line-height: 1;">&times;</button>
            
            <h2 style="color: var(--accent-color); margin-bottom: 1.5rem; font-family: 'Playfair Display', serif;">Create Shopping Swarm</h2>
            
            <form id="createSwarmForm" onsubmit="submitSwarm(event)">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Title *</label>
                    <input type="text" name="swarmTitle" required maxlength="60" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="Saturday Market Crawl">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                    <div>
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Date *</label>
                        <input type="date" name="swarmDate" id="swarmDateInput" required style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                    </div>
                    <div>
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Time *</label>
                        <input type="time" name="swarmTime" required style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                    </div>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Expected Duration</label>
                    <select name="swarmDuration" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                        <option value="">Select duration...</option>
                        <option value="1 hour">1 hour</option>
                        <option value="2 hours">2 hours</option>
                        <option value="3+ hours">3+ hours</option>
                    </select>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Description (200 characters max)</label>
                    <p style="color: #999; font-size: 0.85rem; margin-bottom: 0.5rem;">This will be visible to others when viewing swarms</p>
                    <textarea name="swarmDescription" maxlength="200" rows="3" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem; resize: vertical;" placeholder="Hitting 3 coffee shops in the Arts District"></textarea>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Meeting Location *</label>
                    <input type="text" name="swarmMeetingLocation" required maxlength="100" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="e.g., 'Starbucks on 16th Street' or 'Union Station entrance'">
                    <p style="color: #999; font-size: 0.85rem; margin-top: 0.4rem;">Where should the group meet to start?</p>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">How to Identify Group (Optional)</label>
                    <input type="text" name="swarmIdentifier" maxlength="100" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="e.g., 'Blue umbrella' or 'Wearing yellow shirts'">
                    <p style="color: #999; font-size: 0.85rem; margin-top: 0.5rem;">Help others recognize your group at the meeting location</p>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Organizer Name (Optional)</label>
                    <input type="text" name="swarmPostedBy" maxlength="60" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="Your name or organization">
                </div>

                <button type="submit" id="createSwarmBtn" class="feature-btn" style="width: 100%; margin-top: 1rem;" disabled>Create Swarm</button>
            </form>
        </div>
    </div>

    <!-- Create Event Modal -->
    <div id="createEventModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center; padding: 2rem;">
        <div style="background: rgba(25, 25, 25, 0.98); border-radius: 20px; padding: 2.5rem; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; border: 2px solid rgba(107, 155, 158, 0.3); position: relative;">
            <button onclick="closeCreateEventModal()" style="position: absolute; top: 1rem; right: 1rem; background: none; border: none; color: var(--accent-color); font-size: 2rem; cursor: pointer; line-height: 1;">&times;</button>
            
            <h2 style="color: var(--accent-color); margin-bottom: 1.5rem; font-family: 'Playfair Display', serif;">Promote Your Event</h2>
            
            <form id="createEventForm" onsubmit="submitEvent(event)">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Event Name *</label>
                    <input type="text" name="eventName" required maxlength="80" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="Highland Street Festival">
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Location *</label>
                    <input type="text" name="eventLocation" required maxlength="150" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="e.g., 'Red Rocks Amphitheatre' or '1234 Main St, Denver'">
                    <p style="color: #999; font-size: 0.85rem; margin-top: 0.4rem;">Where will this event take place?</p>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                    <div>
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Start Date *</label>
                        <input type="date" name="eventStartDate" id="eventStartDateInput" required style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                    </div>
                    <div>
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Start Time *</label>
                        <input type="time" name="eventStartTime" required style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                    <div>
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">End Date</label>
                        <input type="date" name="eventEndDate" id="eventEndDateInput" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                    </div>
                    <div>
                        <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">End Time</label>
                        <input type="time" name="eventEndTime" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                    </div>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Description * (500 characters max)</label>
                    <textarea name="eventDescription" required maxlength="500" rows="4" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem; resize: vertical;" placeholder="Describe your event..."></textarea>
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Posted By *</label>
                    <input type="text" name="eventPostedBy" required maxlength="60" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="Organization or your name">
                </div>

                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Website/Link (Optional)</label>
                    <input type="text" name="eventWebsite" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="www.example.com or https://example.com">
                </div>


                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Max Participants (Optional)</label>
                    <input type="number" name="eventMaxParticipants" min="1" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="Leave blank for unlimited">
                </div>

                <button type="submit" id="createEventBtn" class="feature-btn" style="width: 100%; margin-top: 1rem;" disabled>Create Event</button>
            </form>
        </div>
    </div>
    
    <!-- Sign In Modal -->
    <div id="signInModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 450px;">
            <span class="close" onclick="closeSignInModal()">&times;</span>
            <h2 style="text-align: center; color: var(--accent-color); margin-bottom: 1.5rem;">Welcome to Fl√¢nerie</h2>
            
            <!-- Google Sign In -->
            <button onclick="signInWithGoogle()" style="width: 100%; padding: 1rem; background: white; color: #333; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem; font-weight: 600; cursor: pointer; margin-bottom: 1.5rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem; transition: all 0.3s ease;">
                <span style="font-size: 1.2rem;">G</span> Sign in with Google
            </button>
            
            <div style="text-align: center; margin: 1.5rem 0; color: #999;">
                ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ OR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            </div>
            
            <!-- Email/Password Tabs -->
            <div style="display: flex; gap: 1rem; margin-bottom: 1.5rem; border-bottom: 2px solid rgba(107, 155, 158, 0.2);">
                <button id="signInTab" class="auth-tab active" onclick="switchAuthTab('signin')" style="flex: 1; padding: 1rem; background: none; border: none; color: var(--accent-light); font-weight: 600; cursor: pointer; border-bottom: 3px solid var(--accent-color); transition: all 0.3s ease;">
                    Sign In
                </button>
                <button id="signUpTab" class="auth-tab" onclick="switchAuthTab('signup')" style="flex: 1; padding: 1rem; background: none; border: none; color: #999; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s ease;">
                    Sign Up
                </button>
            </div>
            
            <!-- Sign In Form -->
            <form id="signInForm" onsubmit="signInWithEmail(event); return false;">
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Email</label>
                    <input type="email" id="signInEmail" required style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                </div>
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Password</label>
                    <input type="password" id="signInPassword" required style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                    <a href="javascript:void(0)" onclick="showForgotPasswordModal()" style="display: block; margin-top: 0.5rem; color: var(--accent-light); font-size: 0.9rem; text-decoration: none;">Forgot Password?</a>
                </div>
                <button type="submit" class="feature-btn" style="width: 100%;">Sign In</button>
            </form>
            
            <!-- Sign Up Form -->
            <form id="signUpForm" style="display: none;" onsubmit="signUpWithEmail(event); return false;">
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Email</label>
                    <input type="email" id="signUpEmail" required style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                </div>
                <div style="margin-bottom: 1rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Password (min 6 characters)</label>
                    <input type="password" id="signUpPassword" required minlength="6" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                </div>
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Username</label>
                    <input type="text" id="signUpDisplayName" required oninput="checkUsernameAvailability()" pattern="[a-zA-Z0-9_]+" minlength="3" maxlength="20" style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;" placeholder="Letters, numbers, underscore only">
                    <p id="usernameStatus" style="margin-top: 0.5rem; font-size: 0.85rem; color: #999;"></p>
                </div>
                <!-- Honeypot field (hidden from humans, bots will fill it) -->
                <input type="text" id="website" name="website" style="position: absolute; left: -9999px; width: 1px; height: 1px;" tabindex="-1" autocomplete="off">
                <button type="submit" class="feature-btn" style="width: 100%;">Sign Up</button>
                <p style="color: #999; font-size: 0.85rem; margin-top: 1rem; text-align: center;">
                    You'll receive a verification email after signing up
                </p>
            </form>
        </div>
    </div>
    
    <!-- Forgot Password Modal -->
    <div id="forgotPasswordModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 450px;">
            <span class="close" onclick="closeForgotPasswordModal()">&times;</span>
            <h2 style="text-align: center; color: var(--accent-color); margin-bottom: 1.5rem;">Reset Password</h2>
            <p style="color: #d4d4d4; margin-bottom: 1.5rem; text-align: center;">
                Enter your email address and we'll send you a link to reset your password.
            </p>
            
            <form id="forgotPasswordForm" onsubmit="sendPasswordResetEmail(event); return false;">
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; color: #d4d4d4; margin-bottom: 0.5rem; font-weight: 600;">Email</label>
                    <input type="email" id="resetEmail" required style="width: 100%; padding: 0.8rem; background: rgba(40, 40, 40, 0.8); border: 2px solid rgba(107, 155, 158, 0.3); border-radius: 10px; color: white; font-size: 1rem;">
                </div>
                <button type="submit" class="feature-btn" style="width: 100%;">Send Reset Link</button>
            </form>
        </div>
    </div>
    
    <!-- Dashboard Modal -->
    <div id="dashboardModal" class="modal" style="display: none;">
        <div class="modal-content" style="max-width: 1200px; width: 95%; max-height: 90vh;">
            <span class="close" onclick="closeDashboard()">&times;</span>
            <h2 style="text-align: center; color: var(--accent-color); margin-bottom: 2rem;">My Dashboard</h2>
            
            <!-- Dashboard Tabs -->
            <div style="display: flex; gap: 1rem; margin-bottom: 2rem; border-bottom: 2px solid rgba(107, 155, 158, 0.3); flex-wrap: wrap;">
                <button id="routesTab" class="dashboard-tab active" onclick="switchDashboardTab('routes')" style="padding: 1rem 1.5rem; background: none; border: none; color: var(--accent-light); font-weight: 600; cursor: pointer; border-bottom: 3px solid var(--accent-color); transition: all 0.3s ease;">
                    My Routes
                </button>
                <button id="swarmsTab" class="dashboard-tab" onclick="switchDashboardTab('swarms')" style="padding: 1rem 1.5rem; background: none; border: none; color: #999; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s ease;">
                    My Swarms
                </button>
                <button id="eventsTab" class="dashboard-tab" onclick="switchDashboardTab('events')" style="padding: 1rem 1.5rem; background: none; border: none; color: #999; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s ease;">
                    My Events
                </button>
                <button id="likesTab" class="dashboard-tab" onclick="switchDashboardTab('likes')" style="padding: 1rem 1.5rem; background: none; border: none; color: #999; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s ease;">
                    My Likes & Interests
                </button>
                <button id="draftsTab" class="dashboard-tab" onclick="switchDashboardTab('drafts')" style="padding: 1rem 1.5rem; background: none; border: none; color: #999; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s ease;">
                    My Drafts
                </button>
                <button id="messagesTab" class="dashboard-tab" onclick="switchDashboardTab('messages')" style="padding: 1rem 1.5rem; background: none; border: none; color: #999; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s ease;">
                    <span id="messagesTabLabel">Messages</span> <span id="unreadBadge" style="display: none; background: #ff4444; color: white; padding: 0.2rem 0.5rem; border-radius: 10px; font-size: 0.75rem; margin-left: 0.3rem;"></span>
                </button>
                <button id="accountTab" class="dashboard-tab" onclick="switchDashboardTab('account')" style="padding: 1rem 1.5rem; background: none; border: none; color: #999; font-weight: 600; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.3s ease;">
                    Account
                </button>
            </div>
            
            <!-- Dashboard Content -->
            <div id="dashboardContent" style="overflow-y: auto; max-height: 60vh;">
                <div id="routesContent" class="dashboard-section">
                    <p style="text-align: center; color: #999;">Loading your routes...</p>
                </div>
                <div id="swarmsContent" class="dashboard-section" style="display: none;">
                    <p style="text-align: center; color: #999;">Loading your swarms...</p>
                </div>
                <div id="eventsContent" class="dashboard-section" style="display: none;">
                    <p style="text-align: center; color: #999;">Loading your events...</p>
                </div>
                <div id="likesContent" class="dashboard-section" style="display: none;">
                    <p style="text-align: center; color: #999;">Loading your likes...</p>
                </div>
                <div id="draftsContent" class="dashboard-section" style="display: none;">
                    <p style="text-align: center; color: #999;">Loading your drafts...</p>
                </div>
                <div id="messagesContent" class="dashboard-section" style="display: none;">
                    <p style="text-align: center; color: #999;">Loading your messages...</p>
                </div>
                <div id="accountContent" class="dashboard-section" style="display: none;">
                    <p style="text-align: center; color: #999;">Loading account settings...</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- PWA Service Worker Registration -->
    <script>
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/service-worker.js')
                    .then((registration) => {
                        console.log('PWA: Service Worker registered successfully:', registration.scope);
                    })
                    .catch((error) => {
                        console.log('PWA: Service Worker registration failed:', error);
                    });
            });
        }
        
        // PWA Install Prompt Handler with Device Detection
        let deferredPrompt;
        const installBanner = document.getElementById('pwa-install-banner');
        const installBtn = document.getElementById('pwa-install-btn');
        const androidText = document.getElementById('pwa-android-text');
        const iosText = document.getElementById('pwa-ios-text');
        
        // Detect device type
        function detectDevice() {
            const userAgent = navigator.userAgent || navigator.vendor || window.opera;
            
            // Check for iOS (includes iPhone, iPad, iPod)
            const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
            
            // Check for Android (includes emulators like Bluestacks)
            const isAndroid = /android/i.test(userAgent);
            
            console.log('PWA: Device detection -', { isIOS, isAndroid, userAgent });
            
            return { isIOS, isAndroid };
        }
        
        // Show appropriate banner content based on device
        function showDeviceSpecificBanner() {
            const { isIOS, isAndroid } = detectDevice();
            
            if (isIOS) {
                // iPhone/iPad - Show manual instructions (no install button)
                iosText.style.display = 'inline';
                androidText.style.display = 'none';
                installBtn.style.display = 'none';
                console.log('PWA: Showing iOS instructions');
            } else if (isAndroid) {
                // Android - Show install button
                androidText.style.display = 'inline';
                iosText.style.display = 'none';
                installBtn.style.display = 'inline-block';
                console.log('PWA: Showing Android instructions');
            } else {
                // Desktop or unknown - show Android version (has button)
                androidText.style.display = 'inline';
                iosText.style.display = 'none';
                installBtn.style.display = 'inline-block';
                console.log('PWA: Showing default (Android) instructions');
            }
            
            // Show the banner (only on mobile/tablet)
            if (window.innerWidth <= 1024) {
                installBanner.classList.add('show');
            }
        }
        
        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent the mini-infobar from appearing on mobile
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            console.log('PWA: Install prompt available');
            
            // Show device-specific banner
            showDeviceSpecificBanner();
        });
        
        // Handle install button click (Android only)
        installBtn.addEventListener('click', async () => {
            if (!deferredPrompt) {
                console.log('PWA: No install prompt available');
                return;
            }
            
            // Show the install prompt
            deferredPrompt.prompt();
            
            // Wait for the user's response
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`PWA: User ${outcome} the install`);
            
            // Hide banner after user responds
            installBanner.classList.remove('show');
            
            // Clear the deferredPrompt
            deferredPrompt = null;
        });
        
        // Track when app is installed
        window.addEventListener('appinstalled', () => {
            console.log('PWA: App installed successfully!');
            installBanner.classList.remove('show');
            deferredPrompt = null;
        });
        
        // For iOS: Show banner on page load (since beforeinstallprompt doesn't fire on iOS)
        window.addEventListener('load', () => {
            const { isIOS } = detectDevice();
            
            // Only show for iOS Safari users who haven't installed yet
            if (isIOS && window.innerWidth <= 1024) {
                // Check if already running as installed app
                const isStandalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
                
                if (!isStandalone) {
                    // Not installed yet, show iOS instructions
                    setTimeout(() => {
                        iosText.style.display = 'inline';
                        androidText.style.display = 'none';
                        installBtn.style.display = 'none';
                        installBanner.classList.add('show');
                        console.log('PWA: Showing iOS banner on page load');
                    }, 2000); // Show after 2 seconds to not be annoying
                }
            }
        });
    </script>
</body>
</html>
